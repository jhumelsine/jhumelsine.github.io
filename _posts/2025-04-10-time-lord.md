---
title: DRAFT – When tests need to confirm temporal behaviors, then become a Time Lord
description: How to take control of time in your tests
unlisted: true
---

<img src="https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/3d1a727e-a197-431c-9c5b-06f831426bb9/dj20rav-8602287b-f755-46d9-98fd-c0efa3fa75fe.png/v1/fill/w_979,h_816,q_70,strp/dali_tryout_study__yes_i_went_and_tried_this__by_the_ironic_monster_dj20rav-pre.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MTMzNCIsInBhdGgiOiJcL2ZcLzNkMWE3MjdlLWExOTctNDMxYy05YzViLTA2ZjgzMTQyNmJiOVwvZGoyMHJhdi04NjAyMjg3Yi1mNzU1LTQ2ZDktOThmZC1jMGVmYTNmYTc1ZmUucG5nIiwid2lkdGgiOiI8PTE2MDAifV1dLCJhdWQiOlsidXJuOnNlcnZpY2U6aW1hZ2Uub3BlcmF0aW9ucyJdfQ.ztkcYmWvSf3nwXqPlqGKRRAITUhz4tHVqon6_wQTDf0" alt="The Persistence of Time" title="Image Source: https://www.deviantart.com/the-ironic-monster/art/Dali-Tryout-Study-Yes-i-went-and-tried-this-1152251959" width = "50%" align="center" style="padding-right: 35px;">

# Introduction
<img src="https://images.rawpixel.com/image_800/cHJpdmF0ZS9sci9pbWFnZXMvd2Vic2l0ZS8yMDIyLTA4L2xyL3drMjY0NjIxMC1pbWFnZS5qcGc.jpg" alt="Tsumani" title="Image Source: https://www.rawpixel.com/search/tsunami?page=1&path=_topics&sort=curated" width = "25%" align="left" style="padding-right: 20px;">

The [Y2K Problem](https://en.wikipedia.org/wiki/Year_2000_problem) is viewed as a nonevent for most of the public, not because it was overhyped, but because the software industry dedicated many resources to ensure that the world didn’t start the new millennium beneath a digital tsunami when the calendar rolled over from 1999 to 2000 and computers around the world might assume that the year was 1900.

<img src="https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExZWZ6eHY4aXQyb3l5dGRiYTQzd2NzdTd5N3huaTVnZHI1bnhseXVzaiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3orif68a9hKYMPslTa/giphy.gif" alt="Simpsons 2000 Ball Drop" title="Image Source: https://giphy.com/gifs/season-11-the-simpsons-11x4-3orif68a9hKYMPslTa" width = "25%" align="right" style="padding-right: 20px;">

Work on the Y2K problem started well before 2000 rolled around. When a Y2K problem was found in the code, it would be addressed, but how would we know if it was effective? What about other Y2K problems still unrevealed? We just couldn’t wait for the ball to drop at midnight on January 1, 2000, and hope for the best.

At my company at the time, we reset the system clocks to 11:59PM December 31, 1999, and observed what happened when they rolled over. We addressed what we found and reset the clocks again. This isn’t a great technique, but it was about the best we could at the time.

# Time Has No Functional Role
[_Does anybody really know what time it is? Does anybody really care?_]( https://en.wikipedia.org/wiki/Does_Anybody_Really_Know_What_Time_It_Is%3F) — [__Robert Lamm__](https://en.wikipedia.org/wiki/Robert_Lamm) from the band: [__Chicago__](https://en.wikipedia.org/wiki/Chicago_(band))

Maybe we don’t care about time. Many behaviors don’t depend upon time. For example, most mathematical functions don’t depend upon time; therefore, any unit test specifications for mathematical functions would be time agnostic.

Sometimes time only appears as a timestamp, such as a create or update timestamp, and it’s not a critical attribute.

For example, a method being tested may return an `Order` that requires some assertions. While the test might include asserts for __Customer__, __Items__, __Quantity__, __Price__, etc., it may not require an assert for __Order.orderPlacedTimestamp__.

This could be a bit more tricky using [Approval Testing](https://jhumelsine.github.io/2025/04/02/approval-testing.html) and the assert is based upon the String representation of the `Order`. It’s likely to contain the __orderPlacedTimestamp__, and if using __System Time__ it will be a different value each time the test is executed. Additional effort may be needed to filter out the timestamp information in the assert.

# Time Has A Functional Role
Sometimes time is a critical element to behavior. Y2K was a ticking timebomb. Here are a few other scenarios where time has a significant role:
* Rolling over to a new Day, Week, Month and Year
* Moving among time zones, such as with ships or aircraft
* February 29 on Leap Years
* Day Light Saving Adjustment Weekends

Do we implement what we think will work, hope for the best and observe what happens? Do we reset the machine clocks repeatedly?

## Heartbeat or Heart Attack?
What about functionality that takes a long time to playout?

About two decades ago, I worked for a startup that made a large fiber optic switch that had the capacity to support about 500 circuit packs. I implemented the feature that rebooted unresponsive circuit packs when more than 2 minutes had transpired since their last heartbeat.

One day, the customer support team called me into their lab. Multiple circuit packs were rebooting for our customers across the country. The circuit packs weren’t rebooting en mass, but they were rebooting in clusters. For example, the circuit packs on one shelf may start to reboot one every several seconds and in order.

We were stymied. I had no logical explanation of how my code could generate a pattern like this. Circuit packs had been running continuously for several weeks. Then we started to notice something. None of the circuit packs had been running for more than about 42 days. We retrieved the running times on all our circuit packs, and none across all our customers had been running for more than 42 days.

Some where at 41 days, so we kept an eye on them, and sure enough, they rebooted at some point on day 42. Someone theorized that we had a rollover issue. Each circuit pack had a counter that issued a heartbeat every several seconds with logic along the lines of:
```java
// If at least 100 ticks have transpired since the last heartbeat, then issue a new heartbeat
if (ticks < lastIssuedHeartbeatTickCount + 100) {
    issueHeartbeat();
    lastIssuedHeartbeatTickCount = ticks;
}
ticks++;

```
However, when the `ticks` counter surpasses its maximum value, it rolled over, and the `if` condition was never true again, so it didn’t issue a heartbeat. My feature waited for two minutes, then rebooted it. We calculated how long it would take for `ticks` to roll over, and it was 42 days.

The circuit pack team fixed the problem, which took a few days to deploy. Customer support reset `ticks` manually for the circuit packs that were getting close to 42 days old.

I chucked to myself, that we would have had to had to let our circuit packs soak continuously in the test lab for 42 days before we noticed it ourselves. We were lucky if the switch ran uninterrupted for more than several hours without being rebooted.

How could we have possibly tested a circuit pack for more than 42 days?

## Become a Time Lord
[_If I could turn back the hands of time._](https://springsteenlyrics.com/lyrics.php?song=turnbackthehandsoftime) — [__Bruce Springsteen__](https://en.wikipedia.org/wiki/Bruce_Springsteen)

<img src="https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/5160a98e-2a12-4372-b617-b393a7f960c2/d35fjuq-5118b6dc-ce1a-44d6-9040-22e4f52e83f3.png/v1/fit/w_828,h_642,q_70,strp/tardis_blueprint_file_001_by_time_lord_rassilon_d35fjuq-414w-2x.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MTI0MSIsInBhdGgiOiJcL2ZcLzUxNjBhOThlLTJhMTItNDM3Mi1iNjE3LWIzOTNhN2Y5NjBjMlwvZDM1Zmp1cS01MTE4YjZkYy1jZTFhLTQ0ZDYtOTA0MC0yMmU0ZjUyZTgzZjMucG5nIiwid2lkdGgiOiI8PTE2MDAifV1dLCJhdWQiOlsidXJuOnNlcnZpY2U6aW1hZ2Uub3BlcmF0aW9ucyJdfQ._R6wybd0hoT8-VozmX3HGZzqMvBYXW55bgFGJ-yK0dM" 
  alt="Tardis Blueprint" title="Image Source: https://www.deviantart.com/time-lord-rassilon/art/Tardis-Blueprint-File-001-190522178" width = "35%" align="right" style="padding-right: 20px;">

Become a Time Lord. Take control of time in your tests. Though we may not want to turn back the hands of time as Bruce muses, we can do the following in our unit tests:
* Set a specific time, which covers cases like Y2K, leap years, etc.
* Make forward time jumps, which could be used to confirm the 42 day problem.
* Emulate the passage of minutes, hours or days while only needed milliseconds in the test

## The Phoenix Project Revisited
[The Phoenix Project](https://www.runn.io/blog/the-phoenix-project-summary) presents the story of technical struggles of fictional __Parts Unlimited__ company as it’s desperately trying to release its new application, _The Phoenix Project_, while trying to keep the rest of the company afloat.

The book has a happy ending, but their story is not over. Let’s listen in:
>Bill Palmer, VP of IT Operations, leaned back in his chair, staring at the charts projected on the conference room screen. Sarah Madsen, Head of Analytics, tapped at her laptop. "We've confirmed it—95% of canceled orders happen within 15 minutes of placement. If we delay fulfillment by just that much, we eliminate most of the restocking costs."
>
>John Stowe, Senior Project Manager, leaned forward. "So, can we do it? Can we just hold the orders before sending them to Fulfillment?"
>
>Brent Geller, Lead Engineer, arms crossed, let out a long breath. "It's never that simple. The fulfillment system isn't designed to ‘pause’ an order once it's in the queue. We'd need a holding mechanism upstream."
>
>"Or," Patty McKee, Director of Development, interjected, "we could introduce an order confirmation buffer. Users place an order, but it sits in a pending state for 15 minutes before finalizing. That way, cancellations happen before the system commits to fulfillment."
>
>"Wouldn't that create a bad user experience?" John asked. "People expect orders to go through instantly."
>
>"Maybe not," Sarah countered. "We could frame it as a ‘grace period’ for order changes. Some customers might even appreciate the flexibility."
>
>Bill nodded. "Alright, let’s assume we build this buffer. How do we test it?"
>
>Brent rubbed his chin. "Unit testing this will be tricky. We’ll need a way to simulate time passing in our tests without actually waiting 15 minutes."
>
>Patty added, "Mocking time-dependent behavior can get messy. We’ll need robust test cases that verify orders are only processed after the soak period expires, without introducing flakiness."
>
>Bill tapped the table. "Sounds like a plan. Let's scope this out, prototype it, and validate with data. If it saves money without hurting customers, it's a win."
>
>Everyone nodded. Another problem, another solution—just another day at Parts Unlimited.

Within the `Orders` class, `Order`s are added to a `List` as they are placed. Then once a minute or so, a process sends each `Order` to `Fulfillment` to be fulfilled. Here’s an example of what `fulfillOrders` looks like (__NOTE:__ The entire code will be listed at the bottom of the blog):
```java
    public void fulfillOrders() {
        for (Order order : orders) {
            fulfillment.fulfill(order);
        }
        orders.clear();
    }
```

Here’s one way to implement Patty’s pending state suggestion:
```java
    public void fulfillOrders() {
        // Iterator avoids Concurrent Mutation Exceptions
        ListIterator<Order> orderIterator = orders.listIterator();
        while (orderIterator.hasNext()) {
            Order order = orderIterator.next();
            if (isMature(order)) {
                fulfillment.fulfill(order);
                orderIterator.remove();
            }
        }
    }

    private boolean isMature(Order order) {
        return order.getPlacedOrderTime().plusMinutes(15).isBefore(LocalDateTime getNow());
    }
```

This works … probably. But how can we be sure? A test for this could would take at least 15 minutes to complete. Fifteen minutes is much too long for a test, but what if we change the policy to 15 hours or 15 days? We need to do something different.

## Time is an External Dependency
The call to `LocalDateTime.getNow()` gives us the current time, but this is an external dependency. The `fulfillOrders()` method is tightly coupled to it as a static call.

Mockito will allow you to mock static calls, but as I mentioned in [Mocking Frameworks](https://jhumelsine.github.io/2025/03/24/legacy-code.html#mocking-frameworks), if you have to mock a static method, that’s probably an indication of a code smell that needs to be addressed.

We can also introduce a seam by extracting `LocalDateTime.getNow()` into its own method, resulting in:
```java
    private boolean isMature(Order order) {
        return order.getPlacedOrderTime().plusMinutes(15).isBefore(getNow());
    }

    LocalDateTime getNow() {
        return LocalDateTime.now();
    }
```

`isMature(…)` depends upon `getNow()`, which being a __protected-private__ method, we can override to return any value desired.  When not overridden, it will return the current time.

Then in the test, I may do something like:
```java
Orders orders = new Orders() {
    @Override
    LocalDateTime getNow() {
        return LocalDateTime.of(2025, 04, 01, 10, 30);
    }
}
```

This is quite useful when I want a specific timestamp returned for a String comparison, but in order to confirm `Orders` for __Parts Unlimited__ we’re going to need something a bit more sophisticated.

Since time is an external dependency, I have designed it to be an external dependency, like I would with a database or filesystem dependency. I’ve defined `Clock` interface:
```java
interface Clock {
    LocalDateTime getNow();
}
```

`Orders` depends upon `Clock`, which will be injected into it. This simplifies `isMature(…)` to:
```java
    private boolean isMature(Order order) {
        return order.getPlacedOrderTime().plusMinutes(15).isBefore(clock.getNow());
    }
```

Here’s an example of the injected `Clock` for production, which is an [Adapter](https://jhumelsine.github.io/2023/09/29/adapter-design-pattern.html):
```java
class SystemClock implements Clock {
    @Override
    public LocalDateTime getNow() {
        return LocalDateTime.now();
    }
}
```

I created this Clock [Test Double](https://jhumelsine.github.io/2024/07/02/test-doubles.html), which allows me to jump forward any number of desired minutes:
```java
class ClockStub implements Clock {
    private LocalDateTime localDateTime;

    public ClockStub(LocalDateTime localDateTime) {
        this.localDateTime = localDateTime;
    }

    public void advanceMinutes(int minutes) {
        localDateTime = localDateTime.plusMinutes(minutes);
    }

    @Override
    public LocalDateTime getNow() {
        return localDateTime;
    }

}
```

And finally with all the parts defined, I can create unit tests that take control of time. My demo, found in full below, has several tests, but here the test that performs a complete scenario. It emulates the passage of 42 minutes functionally but only requires milliseconds to execute.
```java
    private static void ordersOperationalScenario() throws Exception {
        // Given
        ClockStub clockStub = new ClockStub(LocalDateTime.of(2025, 04, 01, 10, 30));
        FulfillmentSpy fulfillmentSpy  = new FulfillmentSpy();
        Orders orders = new Orders(clockStub, fulfillmentSpy);

        // When-Then: Full scenario with multiple Orders calls.

        orders.placeOrder(new Order(1, 41, 1001, 1));
        clockStub.advanceMinutes(5);
        orders.fulfillOrders();
        assertEquals("[]", fulfillmentSpy.getFulfillmentOrders().toString());

        orders.placeOrder(new Order(2, 42, 1002, 2));
        clockStub.advanceMinutes(5);
        orders.fulfillOrders();
        assertEquals("[]", fulfillmentSpy.getFulfillmentOrders().toString());

        orders.placeOrder(new Order(3, 43, 1003, 3));
        orders.cancelOrder(1);
        clockStub.advanceMinutes(16);
        orders.fulfillOrders();
        assertEquals("[Order(orderNumber=2, customerId=42, item=1002, quantity=2, placedOrderTime=2025-04-01T10:35), Order(orderNumber=3, customerId=43, item=1003, quantity=3, placedOrderTime=2025-04-01T10:40)]", fulfillmentSpy.getFulfillmentOrders().toString());

        orders.placeOrder(new Order(4, 44, 1004, 4));
        clockStub.advanceMinutes(16);
        orders.fulfillOrders();
        assertEquals("[Order(orderNumber=2, customerId=42, item=1002, quantity=2, placedOrderTime=2025-04-01T10:35), Order(orderNumber=3, customerId=43, item=1003, quantity=3, placedOrderTime=2025-04-01T10:40), Order(orderNumber=4, customerId=44, item=1004, quantity=4, placedOrderTime=2025-04-01T10:56)]", fulfillmentSpy.getFulfillmentOrders().toString());
    }
```

# Summary
__TBD__

# References
__TBD__

# Complete Demo Code
__TBD__
