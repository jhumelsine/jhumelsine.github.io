---
title: DRAFT – Mastering Time in Software Testing - Strategies for Temporal Behavior Verification
description: Become a Time Lord and take control of time in your tests
unlisted: true
---

<img src="https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/3d1a727e-a197-431c-9c5b-06f831426bb9/dj20rav-8602287b-f755-46d9-98fd-c0efa3fa75fe.png/v1/fill/w_979,h_816,q_70,strp/dali_tryout_study__yes_i_went_and_tried_this__by_the_ironic_monster_dj20rav-pre.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MTMzNCIsInBhdGgiOiJcL2ZcLzNkMWE3MjdlLWExOTctNDMxYy05YzViLTA2ZjgzMTQyNmJiOVwvZGoyMHJhdi04NjAyMjg3Yi1mNzU1LTQ2ZDktOThmZC1jMGVmYTNmYTc1ZmUucG5nIiwid2lkdGgiOiI8PTE2MDAifV1dLCJhdWQiOlsidXJuOnNlcnZpY2U6aW1hZ2Uub3BlcmF0aW9ucyJdfQ.ztkcYmWvSf3nwXqPlqGKRRAITUhz4tHVqon6_wQTDf0" alt="The Persistence of Time" title="Image Source: https://www.deviantart.com/the-ironic-monster/art/Dali-Tryout-Study-Yes-i-went-and-tried-this-1152251959" width = "50%" align="center" style="padding-right: 35px;">

# Introduction
<img src="https://images.rawpixel.com/image_800/cHJpdmF0ZS9sci9pbWFnZXMvd2Vic2l0ZS8yMDIyLTA4L2xyL3drMjY0NjIxMC1pbWFnZS5qcGc.jpg" alt="Tsumani" title="Image Source: https://www.rawpixel.com/search/tsunami?page=1&path=_topics&sort=curated" width = "25%" align="left" style="padding-right: 20px;">

The [Y2K Problem](https://en.wikipedia.org/wiki/Year_2000_problem) is viewed as a nonevent by most of the general public, not because it was overhyped, but because the software industry dedicated many resources to ensure that the world didn’t start the new millennium beneath a digital tsunami when the calendar rolled over from 1999 to 2000 and computers around the world might assume that the year was 1900.

<img src="https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExZWZ6eHY4aXQyb3l5dGRiYTQzd2NzdTd5N3huaTVnZHI1bnhseXVzaiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3orif68a9hKYMPslTa/giphy.gif" alt="Simpsons 2000 Ball Drop" title="Image Source: https://giphy.com/gifs/season-11-the-simpsons-11x4-3orif68a9hKYMPslTa" width = "25%" align="right" style="padding-right: 20px;">

Work to address the Y2K problem started well before 2000 arrived. When a Y2K problem was found in the code, it would be addressed. How would we know if it was effective? What about other Y2K problems still unrevealed? We just couldn’t wait for the ball to drop at the end of 1999, and hope for the best.

At my company, we reset the system clocks to 11:59 PM on December 31, 1999, and observed what happened when they rolled over a minute later. We addressed issues we found and reset the clocks again. This wasn’t a great technique, but it was about the best we could at the time.

# Time Has No Functional Role
[_Does anybody really know what time it is? Does anybody really care?_]( https://en.wikipedia.org/wiki/Does_Anybody_Really_Know_What_Time_It_Is%3F) — [__Robert Lamm__](https://en.wikipedia.org/wiki/Robert_Lamm) from the band: [__Chicago__](https://en.wikipedia.org/wiki/Chicago_(band))

Maybe we don’t care about time. Many behaviors don’t depend upon time. For example, most mathematical functions don’t depend upon time; therefore, unit tests confirming mathematical functions can be time agnostic.

In other cases, time may technically be a behavior, but it may not be critical. A created or updated timestamp for an object is observable behavior, but it may not be that critical to confirm in a test. For example, a method being tested might return an `Order` object, which we wish to test with assertions for important attributes within `Order`, such as: __Customer__, __Items__, __Quantity__, __Price__, etc., But its updated timestamp may not need to be confirmed via an assert.

Asserts could be a bit more tricky when using [Approval Testing](https://jhumelsine.github.io/2025/04/02/approval-testing.html), and the the String representation of the `Order` contains the timestamp. Since it will be a different value each time the test is executed, additional effort may be needed to redact the timestamp so that it won't cause the assertion to fail.

# Time May Play A Functional Role
Sometimes time is a critical element to behavior. Y2K was a ticking timebomb. Here are a few scenarios where time plays a significant role:
* Rolling over to a new Day, Week, Month and Year
* Moving among time zones, such as with ships or aircraft, especially when crossing the International Date Line
* Leap Years; don't forget that we'll need February 29 every four years
* Day Light Saving Adjustment Weekends

Do we implement what we think will work, hope for the best and observe what happens? Do we reset the machine clocks repeatedly?

## Heartbeat or Heart Attack?
What about functionality that takes a long time to playout?

About two decades ago, I worked for a startup that made a large fiber optic switch, which had the capacity to support around 500 circuit packs. I implemented the feature that rebooted unresponsive circuit packs when more than two minutes had transpired since their last heartbeat notification.

One day, the customer support team called me into their lab. Multiple circuit packs were rebooting for our customers across the country. The circuit packs weren’t rebooting en mass, but they were rebooting in clusters. For example, the circuit packs on one shelf would reboot in succession every several seconds as if one rebooting circuit pack caused its neighbor to reboot two or three seconds later.

We were stymied. I had no logical explanation of how my code could generate a pattern like this. Circuit packs had been running continuously for several weeks. Then we noticed something. None of our customers' circuit packs had been running for more than 42 days in production.

Some where at 41 days, so we kept an eye on them, and sure enough, they rebooted at some point on day 42. Someone theorized that we had a rollover issue. Each circuit pack had a `ticks` counter that issued a heartbeat every several seconds with an implementation similar to this:
```java
// If at least 100 ticks have transpired since the last heartbeat, then issue a new heartbeat
if (ticks < lastIssuedHeartbeatTickCount + 100) {
    issueHeartbeat();
    lastIssuedHeartbeatTickCount = ticks;
}
ticks++;

```
When the `ticks` counter surpasses its maximum value, it rolled over, basically resetting it, and the `if` condition was never true again, so it never issued another heartbeat. My feature waited for two minutes without a heartbeat notification, then rebooted stuck circuit pack. We calculated how long it would take for `ticks` to roll over, and it was 42 days.

The confusing behavior of circuits rebooting in succession on the same shelf every few seconds now made sense. 42 days previously, a technician had manually inserted the circuit packs into their slots, which required a few seconds between each insertion to ensure the circuit pack was seated properly in the slot with its latches closed. Each circuit pack's 42-day `ticks` counter began as it was inserted. Each circuit pack's `ticks` counter had a staggered start time like the staggered start of a road rally race.

The circuit pack team fixed the problem, which took a few days to deploy. Customer support reset `ticks` manually for the circuit packs that were getting close to 42 days old so that our customers wouldn't experience any more random reboots until the fix was fully deployed.

I chucked to myself that we would have had to had to let our circuit packs soak continuously in the test lab for 42 days before we noticed it ourselves. We were lucky if the switch ran uninterrupted in the test lab for more than several hours without being rebooted.

## Become a Time Lord

<img src="https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/5160a98e-2a12-4372-b617-b393a7f960c2/d35fjuq-5118b6dc-ce1a-44d6-9040-22e4f52e83f3.png/v1/fit/w_828,h_642,q_70,strp/tardis_blueprint_file_001_by_time_lord_rassilon_d35fjuq-414w-2x.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MTI0MSIsInBhdGgiOiJcL2ZcLzUxNjBhOThlLTJhMTItNDM3Mi1iNjE3LWIzOTNhN2Y5NjBjMlwvZDM1Zmp1cS01MTE4YjZkYy1jZTFhLTQ0ZDYtOTA0MC0yMmU0ZjUyZTgzZjMucG5nIiwid2lkdGgiOiI8PTE2MDAifV1dLCJhdWQiOlsidXJuOnNlcnZpY2U6aW1hZ2Uub3BlcmF0aW9ucyJdfQ._R6wybd0hoT8-VozmX3HGZzqMvBYXW55bgFGJ-yK0dM" 
  alt="Tardis Blueprint" title="Image Source: https://www.deviantart.com/time-lord-rassilon/art/Tardis-Blueprint-File-001-190522178" width = "40%" align="right" style="padding-right: 20px;">

[_If I could turn back the hands of time._](https://springsteenlyrics.com/lyrics.php?song=turnbackthehandsoftime) — [__Bruce Springsteen__](https://en.wikipedia.org/wiki/Bruce_Springsteen)

How could we have possibly tested a circuit pack for more than 42 days?

Become a Time Lord. Take control of time in your tests. Though we do not want to turn back the hands of time in our test scenarios as Bruce muses, we can do the following in our unit tests:
* Set a specific time, which covers cases like Y2K, leap years, etc.
* Make significant forward time jumps, which could be used to confirm the 42 day problem.
* Emulate the passage of minutes, hours or days while only needed milliseconds in the test.
* Maybe we do want to turn back the hands of time in some scenarios, such as crossing the International Date Line in moving from west to east or when rolling the clocks back one hour when moving from daylight saving to standard time.

## The Phoenix Project Revisited
[The Phoenix Project](https://www.runn.io/blog/the-phoenix-project-summary) presents the story of technical struggles of fictional __Parts Unlimited__ company as it’s desperately trying to release its new _Phoenix Project_ application while trying to keep the rest of the company afloat.

The book has a happy ending, but their story is not over, which I've continued in [_my_ fan fiction](#full-disclosure). Let’s listen in:
>Bill Palmer, VP of IT Operations, leaned back in his chair, staring at the charts projected on the conference room screen. Sarah Madsen, Head of Analytics, tapped at her laptop. "We've confirmed it—95% of canceled orders happen within 15 minutes of placement. If we delay fulfillment by just that much, we eliminate most of the restocking costs."
>
>John Stowe, Senior Project Manager, leaned forward. "So, can we do it? Can we just hold the orders before sending them to Fulfillment?"
>
>Brent Geller, Lead Engineer, arms crossed, let out a long breath. "It's never that simple. The fulfillment system isn't designed to ‘pause’ an order once it's in the queue. We'd need a holding mechanism upstream."
>
>"Or," Patty McKee, Director of Development, interjected, "we could introduce an order confirmation buffer. Users place an order, but it sits in a pending state for 15 minutes before finalizing. That way, cancellations happen before the system commits to fulfillment."
>
>"Wouldn't that create a bad user experience?" John asked. "People expect orders to go through instantly."
>
>"Maybe not," Sarah countered. "We could frame it as a ‘grace period’ for order changes. Some customers might even appreciate the flexibility."
>
>Bill nodded. "Alright, let’s assume we build this buffer. How do we test it?"
>
>Brent rubbed his chin. "Unit testing this will be tricky. We’ll need a way to simulate time passing in our tests without actually waiting 15 minutes."
>
>Patty added, "Mocking time-dependent behavior can get messy. We’ll need robust test cases that verify orders are only processed after the soak period expires, without introducing flakiness."
>
>Bill tapped the table. "Sounds like a plan. Let's scope this out, prototype it, and validate with data. If it saves money without hurting customers, it's a win."
>
>Everyone nodded. Another problem, another solution—just another day at Parts Unlimited.

_The Phoenix Project_ doesn't provide any implementation examples, but let's assume that the subsequent code examples illustrates what their code may:
* Manage `Orders`
* Introduce the 15-minute pending state
* Go about testing the 15-minute pending state

Within the `Orders` class, `Order` objects are added `orders`, a `List<Order>`, as the `Order`s are placed. Then once a minute, a separate process thread calls `Orders.fulfillOrders()`, which sends each `Order` to `Fulfillment` to be fulfilled and clears its `orders` `List`. Here’s an example of what `fulfillOrders()` looks like (__NOTE:__ The [entire code example](#complete-demo-code) is listed at the bottom of the blog):
```java
    public void fulfillOrders() {
        for (Order order : orders) {
            fulfillment.fulfill(order);
        }
        orders.clear();
    }
```

Here’s one way to implement Patty’s 15 minute pending state suggestion:
```java
    public void fulfillOrders() {
        // Iterator avoids Concurrent Mutation Exceptions
        ListIterator<Order> orderIterator = orders.listIterator();
        while (orderIterator.hasNext()) {
            Order order = orderIterator.next();
            if (isMature(order)) {
                fulfillment.fulfill(order);
                orderIterator.remove();
            }
        }
    }

    private boolean isMature(Order order) {
        return order.getPlacedOrderTime().plusMinutes(15).isBefore(LocalDateTime getNow());
    }
```

This works … probably. But how can we be sure? A test for this would take at least 15 minutes to complete. Fifteen minutes is much too long for a test, and what if we change the pending policy to 15 hours or 15 days? We probably wouldn't have pending orders for this long, but other applications could take this long. For example, it may take days before the notification for a delinquent payment is sent. How can we test something that doesn't trigger for days?

## Time is an External Dependency
The call to `LocalDateTime.getNow()` gives us the current time, but __time__ is an external dependency. The `fulfillOrders()` method is tightly coupled to it as a static call.

Mockito will allow you to mock static calls, but as I mentioned in [Mocking Frameworks](https://jhumelsine.github.io/2025/03/24/legacy-code.html#mocking-frameworks), if you have to mock a static method, that’s probably an indication of a code smell that needs to be addressed.

We can also introduce a seam by extracting `LocalDateTime.getNow()` into its own method, resulting in:
```java
    private boolean isMature(Order order) {
        return order.getPlacedOrderTime().plusMinutes(15).isBefore(getNow());
    }

    LocalDateTime getNow() {
        return LocalDateTime.now();
    }
```

`isMature(Order order)` depends upon `getNow()`, which being a __protected-private__ method, we can override to return any value desired.  When not overridden, it will return the current system time.

Then in the test, we can do something like:
```java
Orders orders = new Orders() {
    @Override
    LocalDateTime getNow() {
        return LocalDateTime.of(2025, 04, 01, 10, 30);
    }
}
```

This is quite useful when we want a specific timestamp returned for a String comparison, but in order to confirm the new 15-minute feature in `Orders` for __Parts Unlimited__ we’re going to need something a bit more sophisticated.

Since time is an external dependency, I am treating it like any other external dependency, like I would with a database or filesystem dependency. See: [Hexagonal Architecture Structure](https://jhumelsine.github.io/2023/10/28/hexagonal-architecture-structure.html).

I’ve defined a `Clock` interface:
```java
interface Clock {
    LocalDateTime getNow();
}
```

`Orders` depend upon `Clock`, which will be injected into it. This simplifies `isMature(Order order)` to:
```java
    private boolean isMature(Order order) {
        return order.getPlacedOrderTime().plusMinutes(15).isBefore(clock.getNow());
    }
```

Here’s an example of the implementation of the injected `SystemClock`, which would be used in production. `SystemClock` is an [Adapter](https://jhumelsine.github.io/2023/09/29/adapter-design-pattern.html):
```java
class SystemClock implements Clock {
    @Override
    public LocalDateTime getNow() {
        return LocalDateTime.now();
    }
}
```

I created the `ClockStub` [Test Double](https://jhumelsine.github.io/2024/07/02/test-doubles.html), which allows me to advance forward any number of desired minutes:
```java
class ClockStub implements Clock {
    private LocalDateTime localDateTime;

    public ClockStub(LocalDateTime localDateTime) {
        this.localDateTime = localDateTime;
    }

    public void advanceMinutes(int minutes) {
        localDateTime = localDateTime.plusMinutes(minutes);
    }

    @Override
    public LocalDateTime getNow() {
        return localDateTime;
    }

}
```

And finally with all the parts defined, I can create unit tests that take control of time. My [demo](#complete-demo-code), found in full below, has several tests, but here is the test that emulates the passage of 42 minutes functionally but only requires milliseconds to execute.
```java
    private static void ordersOperationalScenario() throws Exception {
        // Given
        ClockStub clockStub = new ClockStub(LocalDateTime.of(2025, 04, 01, 10, 30));
        FulfillmentSpy fulfillmentSpy  = new FulfillmentSpy();
        Orders orders = new Orders(clockStub, fulfillmentSpy);

        // When-Then: Full scenario with multiple Orders calls.

        orders.placeOrder(new Order(1, 41, 1001, 1));
        clockStub.advanceMinutes(5);
        orders.fulfillOrders();
        assertEquals("[]", fulfillmentSpy.getFulfillmentOrders().toString());

        orders.placeOrder(new Order(2, 42, 1002, 2));
        clockStub.advanceMinutes(5);
        orders.fulfillOrders();
        assertEquals("[]", fulfillmentSpy.getFulfillmentOrders().toString());

        orders.placeOrder(new Order(3, 43, 1003, 3));
        orders.cancelOrder(1);
        clockStub.advanceMinutes(16);
        orders.fulfillOrders();
        assertEquals("[Order(orderNumber=2, customerId=42, item=1002, quantity=2, placedOrderTime=2025-04-01T10:35), Order(orderNumber=3, customerId=43, item=1003, quantity=3, placedOrderTime=2025-04-01T10:40)]", fulfillmentSpy.getFulfillmentOrders().toString());

        orders.placeOrder(new Order(4, 44, 1004, 4));
        clockStub.advanceMinutes(16);
        orders.fulfillOrders();
        assertEquals("[Order(orderNumber=2, customerId=42, item=1002, quantity=2, placedOrderTime=2025-04-01T10:35), Order(orderNumber=3, customerId=43, item=1003, quantity=3, placedOrderTime=2025-04-01T10:40), Order(orderNumber=4, customerId=44, item=1004, quantity=4, placedOrderTime=2025-04-01T10:56)]", fulfillmentSpy.getFulfillmentOrders().toString());
    }
```

# Summary
Effective testing of time-sensitive code requires more than just a few sleep statements and crossed fingers. It demands isolating time as a dependency, using mocks or controlled time providers, and accounting for edge cases like daylight savings, leap years, and clock drift. By treating time as a first-class concern in our tests, we can avoid costly bugs and unexpected failures.

# References
Here are some free resources:
* [BDD Testing Time](https://www.youtube.com/watch?v=Xa6UEHyEyzQ) - Video by Dave Farley describing how to ingore or take control of time in your tests
* [The Phoenix Project - Book Club](https://red-green-refactor.com/2020/05/27/book-club-the-phoenix-project-chapters-1-3/) - Book club for the first three chapters of _The Phoenix Project_ with links to additional book club pages for the remaining chapters of the book
* [The Phoenix Project - Summary](https://www.runn.io/blog/the-phoenix-project-summary) - Summarizes the main points of the book
  
Here are some resources that can be purchased or are included in a subscription service:
* _The Phoenix Project_ ([O'Reilly](https://learning.oreilly.com/library/view/the-phoenix-project/9781457191350/) and [Amazon](https://www.amazon.com/gp/product/B0812C82T9?ref_=dbs_m_mng_rwt_calw_taud_1&storeType=ebooks&qid=1743797948))

# Full Disclosure
I did not write _The Phoenix Project_ fan fiction provided above in [The Phoenix Project Revisited](#the-phoenix-project-revisited). It was written by ChatGPT. 

I had already written the demo code, listed below. I wanted a story to provide context for a 15-minute delay. Rather than invent a story from scratch, _The Phoenix Project_ came to mind. I asked ChatGPT if it knew the book and whether it could create some fan fiction for me. When it said it could, I gave it this prompt:
>Here are the main story point elements that must be in this fan fiction version of "The Phoenix Project":
>* The Phoenix Project has been a success. Placed orders are sent to fulfillment, but analytics has noticed that sometimes users cancel their orders after they have been fulfilled. This incurs additional expense to restock the parts for the cancelled order.
>* Analytics also notices that 95% of these cancellations come within 15 minutes of the order being placed.
>* The project managers want to know if Orders can be held for 15 minutes before sending them to Fulfillment. That way, 95% of the cancelled orders won't incur the restocking fee.
>* The development teams consider this behavior update and how they could test it.
>
>Create a Phoenix Project inspired fan fiction story for this. It should be less than 300 words.

The original story included _A/B Testing_, which I see how it generated from the third bullet I provided. I updated my prompt to focus upon unit testing the 15-minute delay rather than the _A/B Testing_. Its original _A/B Testing_ suggestion would be a good way to determine whether the 15-minute delay actually worked in production with the users as expected.

I added a few more prompts but only with respect to how characters were introduced and how their names were presented. While some original characters from the book appear in the generated fan fiction, ChatGPT created new convincing characters as well. It also generated the "grace period" concept as well as the specifics generally associated with time in unit tests including how they can be flaky if not implemented correctly.

# Complete Demo Code
Here’s the entire implementation up to this point as one file. Copy and paste it into a Java environment and execute it. If you don’t have Java, try this [Online Java Environment](https://www.programiz.com/java-programming/online-compiler/). Add more tests. Play with the implementation. Refactor some of the code.

```java
import java.time.*;
import java.util.*;

public class TimeLord {
    public static void main(String[] args) throws Exception {
        Test.test();
    }
}

///////////// SOFTWARE UNDER TEST //////////////////

class Orders {
    private final Clock clock;
    private final Fulfillment fulfillment;
    private final List<Order> orders = new LinkedList<>();

    public Orders(Clock clock, Fulfillment fulfillment) {
        this.clock = clock;
        this.fulfillment = fulfillment;
    }

    public void placeOrder(Order order) {
        order.orderPlaced(clock.getNow());
        orders.add(order);
    }

    public void cancelOrder(int orderNumber) {
        // Iterator avoids Concurrent Mutation Exceptions
        ListIterator<Order> orderIterator = orders.listIterator();
        while (orderIterator.hasNext()) {
            Order order = orderIterator.next();
            if (order.getOrderNumber() == orderNumber) {
                orderIterator.remove();
            }
        }
    }

    public void fulfillOrders() {
        // Iterator avoids Concurrent Mutation Exceptions
        ListIterator<Order> orderIterator = orders.listIterator();
        while (orderIterator.hasNext()) {
            Order order = orderIterator.next();
            if (isMature(order)) {
                fulfillment.fulfill(order);
                orderIterator.remove();
            }
        }
    }

    private boolean isMature(Order order) {
        return order.getPlacedOrderTime().plusMinutes(15).isBefore(clock.getNow());
    }

}

class Order {
    private final int orderNumber;
    private final int customerId;
    private final int itemId;
    private final int quantity;
    private LocalDateTime placedOrderTime;

    public Order(int orderNumber, int customerId, int itemId, int quantity) {
        this.orderNumber = orderNumber;
        this.customerId = customerId;
        this.itemId = itemId;
        this.quantity = quantity;
    }

    public void orderPlaced(LocalDateTime placedOrderTime) {
        this.placedOrderTime = placedOrderTime;
    }

    public LocalDateTime getPlacedOrderTime() {
        return placedOrderTime;
    }

    public int getOrderNumber() {
        return orderNumber;
    }

    @Override 
    public String toString() {
        return String.format("Order(orderNumber=%d, customerId=%d, item=%d, quantity=%d, placedOrderTime=%s)", orderNumber, customerId, itemId, quantity, placedOrderTime.toString());
    }

}

//////////// DEPENDENCY INTERFACES AND PRODUCTION IMPLEMENTATIONS ///////////////////

interface Clock {
    LocalDateTime getNow();
}

// NOTE: This is the Adapter Design Pattern. See: https://jhumelsine.github.io/2023/09/29/adapter-design-pattern.html
class SystemClock implements Clock {
    @Override
    public LocalDateTime getNow() {
        return LocalDateTime.now();
    }
}

interface Fulfillment {
    void fulfill(Order order);
}

// We don't need ProductionFulfillment for this demo.

////////////// TEST DOUBLES /////////////////

// This Stub allows us to take control of time.
class ClockStub implements Clock {
    private LocalDateTime localDateTime;

    public ClockStub(LocalDateTime localDateTime) {
        this.localDateTime = localDateTime;
    }

    public void advanceMinutes(int minutes) {
        localDateTime = localDateTime.plusMinutes(minutes);
    }

    @Override
    public LocalDateTime getNow() {
        return localDateTime;
    }

}

// This Spy records interactions with Fulfillment
class FulfillmentSpy implements Fulfillment {
    private List<Order> fulfilledOrders = new LinkedList<>();

    @Override
    public void fulfill(Order order) {
        fulfilledOrders.add(order);
    }

    public List<Order> getFulfillmentOrders() {
        return fulfilledOrders;
    }
}

/////////////// TESTS ////////////////
class Test {
    public static void test() throws Exception {
        placedOrderNotMatureEnoughToFulfill();

        placedOrderNotQuiteMatureEnoughToFulfill();

        placedOrderMatureEnoughToFulfill();

        multipleMaturePlacedOrdersAreFulfilledButLastIsNotMature();

        canceledOrderBeforeMaturityNotFulfilled();

        ordersOperationalScenario();

        System.out.format("End Tests");
    }

    private static void placedOrderNotMatureEnoughToFulfill() throws Exception {
        // Given
        FulfillmentSpy fulfillmentSpy  = new FulfillmentSpy();
        Orders orders = new Orders(new SystemClock(), fulfillmentSpy);

        orders.placeOrder(new Order(1, 1, 1001, 1));

        // When
        orders.fulfillOrders();

        // Then
        assertEquals("[]", fulfillmentSpy.getFulfillmentOrders().toString());
    }

    private static void placedOrderNotQuiteMatureEnoughToFulfill() throws Exception {
        // Given
        ClockStub clockStub = new ClockStub(LocalDateTime.of(2025, 04, 01, 10, 30));
        FulfillmentSpy fulfillmentSpy  = new FulfillmentSpy();
        Orders orders = new Orders(clockStub, fulfillmentSpy);

        orders.placeOrder(new Order(1, 1, 1001, 1));

        clockStub.advanceMinutes(15);

        // When
        orders.fulfillOrders();

        // Then
        assertEquals("[]", fulfillmentSpy.getFulfillmentOrders().toString());
    }

    private static void placedOrderMatureEnoughToFulfill() throws Exception {
        // Given
        ClockStub clockStub = new ClockStub(LocalDateTime.of(2025, 04, 01, 10, 30));
        FulfillmentSpy fulfillmentSpy  = new FulfillmentSpy();
        Orders orders = new Orders(clockStub, fulfillmentSpy);

        orders.placeOrder(new Order(1, 1, 1001, 1));
        clockStub.advanceMinutes(16);

        // When
        orders.fulfillOrders();
        orders.fulfillOrders(); // Confirms idempotence. Fulfill should only receive the order once.

        // Then
        assertEquals("[Order(orderNumber=1, customerId=1, item=1001, quantity=1, placedOrderTime=2025-04-01T10:30)]", fulfillmentSpy.getFulfillmentOrders().toString());
    }

    private static void multipleMaturePlacedOrdersAreFulfilledButLastIsNotMature() throws Exception {
        // Given
        ClockStub clockStub = new ClockStub(LocalDateTime.of(2025, 04, 01, 10, 30));
        FulfillmentSpy fulfillmentSpy  = new FulfillmentSpy();
        Orders orders = new Orders(clockStub, fulfillmentSpy);

        orders.placeOrder(new Order(1, 41, 1001, 1));
        clockStub.advanceMinutes(5);

        orders.placeOrder(new Order(2, 42, 1002, 2));
        clockStub.advanceMinutes(5);

        orders.placeOrder(new Order(3, 43, 1003, 3));
        clockStub.advanceMinutes(15);

        // When
        orders.fulfillOrders();
        orders.fulfillOrders(); // Confirms idempotence. Fulfill should only receive an order once.

        // Then
        assertEquals("[Order(orderNumber=1, customerId=41, item=1001, quantity=1, placedOrderTime=2025-04-01T10:30), Order(orderNumber=2, customerId=42, item=1002, quantity=2, placedOrderTime=2025-04-01T10:35)]", fulfillmentSpy.getFulfillmentOrders().toString());
    }

    private static void canceledOrderBeforeMaturityNotFulfilled() throws Exception {
        // Given
        ClockStub clockStub = new ClockStub(LocalDateTime.of(2025, 04, 01, 10, 30));
        FulfillmentSpy fulfillmentSpy  = new FulfillmentSpy();
        Orders orders = new Orders(clockStub, fulfillmentSpy);

        orders.placeOrder(new Order(1, 41, 1001, 1));
        clockStub.advanceMinutes(5);

        orders.cancelOrder(1);
        clockStub.advanceMinutes(15);

        // When
        orders.fulfillOrders();

        // Then
        assertEquals("[]", fulfillmentSpy.getFulfillmentOrders().toString());
    }

    private static void ordersOperationalScenario() throws Exception {
        // Given
        ClockStub clockStub = new ClockStub(LocalDateTime.of(2025, 04, 01, 10, 30));
        FulfillmentSpy fulfillmentSpy  = new FulfillmentSpy();
        Orders orders = new Orders(clockStub, fulfillmentSpy);

        // When-Then: Full scenario with multiple Orders calls.

        orders.placeOrder(new Order(1, 41, 1001, 1));
        clockStub.advanceMinutes(5);
        orders.fulfillOrders();
        assertEquals("[]", fulfillmentSpy.getFulfillmentOrders().toString());

        orders.placeOrder(new Order(2, 42, 1002, 2));
        clockStub.advanceMinutes(5);
        orders.fulfillOrders();
        assertEquals("[]", fulfillmentSpy.getFulfillmentOrders().toString());

        orders.placeOrder(new Order(3, 43, 1003, 3));
        orders.cancelOrder(1);
        clockStub.advanceMinutes(16);
        orders.fulfillOrders();
        assertEquals("[Order(orderNumber=2, customerId=42, item=1002, quantity=2, placedOrderTime=2025-04-01T10:35), Order(orderNumber=3, customerId=43, item=1003, quantity=3, placedOrderTime=2025-04-01T10:40)]", fulfillmentSpy.getFulfillmentOrders().toString());

        orders.placeOrder(new Order(4, 44, 1004, 4));
        clockStub.advanceMinutes(16);
        orders.fulfillOrders();
        assertEquals("[Order(orderNumber=2, customerId=42, item=1002, quantity=2, placedOrderTime=2025-04-01T10:35), Order(orderNumber=3, customerId=43, item=1003, quantity=3, placedOrderTime=2025-04-01T10:40), Order(orderNumber=4, customerId=44, item=1004, quantity=4, placedOrderTime=2025-04-01T10:56)]", fulfillmentSpy.getFulfillmentOrders().toString());
    }
    
    private static void assertEquals(String expected, String actual) throws Exception {
        if (!expected.equals(actual)) {
            System.out.format("expected=%s, actual=%s\n", expected, actual);
            throw new Exception();
        }
    }

}
```
