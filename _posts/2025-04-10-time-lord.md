---
title: DRAFT – When tests need to confirm temporal behaviors, then become a Time Lord
description: How to take control of time in your tests
unlisted: true
---

<img src="https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/3d1a727e-a197-431c-9c5b-06f831426bb9/dj20rav-8602287b-f755-46d9-98fd-c0efa3fa75fe.png/v1/fill/w_979,h_816,q_70,strp/dali_tryout_study__yes_i_went_and_tried_this__by_the_ironic_monster_dj20rav-pre.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MTMzNCIsInBhdGgiOiJcL2ZcLzNkMWE3MjdlLWExOTctNDMxYy05YzViLTA2ZjgzMTQyNmJiOVwvZGoyMHJhdi04NjAyMjg3Yi1mNzU1LTQ2ZDktOThmZC1jMGVmYTNmYTc1ZmUucG5nIiwid2lkdGgiOiI8PTE2MDAifV1dLCJhdWQiOlsidXJuOnNlcnZpY2U6aW1hZ2Uub3BlcmF0aW9ucyJdfQ.ztkcYmWvSf3nwXqPlqGKRRAITUhz4tHVqon6_wQTDf0" alt="The Persistence of Time" title="Image Source: https://www.deviantart.com/the-ironic-monster/art/Dali-Tryout-Study-Yes-i-went-and-tried-this-1152251959" width = "50%" align="center" style="padding-right: 35px;">

# Introduction
<img src="https://images.rawpixel.com/image_800/cHJpdmF0ZS9sci9pbWFnZXMvd2Vic2l0ZS8yMDIyLTA4L2xyL3drMjY0NjIxMC1pbWFnZS5qcGc.jpg" alt="Tsumani" title="Image Source: https://www.rawpixel.com/search/tsunami?page=1&path=_topics&sort=curated" width = "25%" align="left" style="padding-right: 20px;">

The [Y2K Problem](https://en.wikipedia.org/wiki/Year_2000_problem) is viewed as a nonevent by most of the public, not because it was overhyped, but because the software industry dedicated many resources to ensure that the world didn’t start the new millennium beneath a digital tsunami when the calendar rolled over from 1999 to 2000 and computers around the world might assume that the year was 1900.

<img src="https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExZWZ6eHY4aXQyb3l5dGRiYTQzd2NzdTd5N3huaTVnZHI1bnhseXVzaiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3orif68a9hKYMPslTa/giphy.gif" alt="Simpsons 2000 Ball Drop" title="Image Source: https://giphy.com/gifs/season-11-the-simpsons-11x4-3orif68a9hKYMPslTa" width = "25%" align="right" style="padding-right: 20px;">

Work to address the Y2K problem started well before 2000 rolled around. When a Y2K problem was found in the code, it would be addressed, but how would we know if it was effective? What about other Y2K problems still unrevealed? We just couldn’t wait for the ball to drop at the end of 1999, and hope for the best.

At my company at the time, we reset the system clocks to December 31, 1999 at 11:59 PM, and observed what happened when they rolled over a minute later. We addressed what we found and reset the clocks again. This isn’t a great technique, but it was about the best we could at the time.

# Time Has No Functional Role
[_Does anybody really know what time it is? Does anybody really care?_]( https://en.wikipedia.org/wiki/Does_Anybody_Really_Know_What_Time_It_Is%3F) — [__Robert Lamm__](https://en.wikipedia.org/wiki/Robert_Lamm) from the band: [__Chicago__](https://en.wikipedia.org/wiki/Chicago_(band))

Maybe we don’t care about time. Many behaviors don’t depend upon time. For example, most mathematical functions don’t depend upon time; therefore, any unit test specifications for mathematical functions would be time agnostic.

Sometimes the only time related behavior appears as a created or updated timestamp for an object, and it’s not a critical functional attribute.

For example, a method being tested may return an `Order` that requires test assertions. While the test might assert __Customer__, __Items__, __Quantity__, __Price__, etc., it may not require an assert for __Order.orderPlacedTimestamp__.

Asserts could be a bit more tricky when using [Approval Testing](https://jhumelsine.github.io/2025/04/02/approval-testing.html) and the the String representation of the `Order` contains __orderPlacedTimestamp__. Since it will be a different timestamp value each time the test is executed, additional effort may be needed to redact the timestamp information in the assert so that it won't cause the assertion to fail.

# Time Has A Functional Role
Sometimes time is a critical element to behavior. Y2K was a ticking timebomb. Here are a few scenarios where time plays a significant role:
* Rolling over to a new Day, Week, Month and Year
* Moving among time zones, such as with ships or aircraft
* Leap Years; don't forget that we'll need February 29 every four years
* Day Light Saving Adjustment Weekends

Do we implement what we think will work, hope for the best and observe what happens? Do we reset the machine clocks repeatedly?

## Heartbeat or Heart Attack?
What about functionality that takes a long time to playout?

About two decades ago, I worked for a startup that made a large fiber optic switch, which had the capacity to support about 500 circuit packs. I implemented the feature that rebooted unresponsive circuit packs when more than 2 minutes had transpired since my feature had received their last heartbeat notification.

One day, the customer support team called me into their lab. Multiple circuit packs were rebooting for our customers across the country. The circuit packs weren’t rebooting en mass, but they were rebooting in clusters. For example, the circuit packs on one shelf may start to reboot one every several seconds and in order.

We were stymied. I had no logical explanation of how my code could generate a pattern like this. Circuit packs had been running continuously for several weeks. Then we started to notice something. None of the circuit packs had been running for more than about 42 days. We retrieved the running times on all our circuit packs, and none across all our customers had been running for more than 42 days.

Some where at 41 days, so we kept an eye on them, and sure enough, they rebooted at some point on day 42. Someone theorized that we had a rollover issue. Each circuit pack had a counter that issued a heartbeat every several seconds with logic along the lines of:
```java
// If at least 100 ticks have transpired since the last heartbeat, then issue a new heartbeat
if (ticks < lastIssuedHeartbeatTickCount + 100) {
    issueHeartbeat();
    lastIssuedHeartbeatTickCount = ticks;
}
ticks++;

```
When the `ticks` counter surpasses its maximum value, it rolled over, and the `if` condition was never true again, so it didn’t issue a heartbeat. My feature waited for two minutes, then rebooted it. We calculated how long it would take for `ticks` to roll over, and it was 42 days. The odd behavior of observing circuits rebooting on the same shelf every few seconds now made sense. 42 days previously, a technician had manually inserted the circuit packs into their slots, which required a few seconds between each insertion to ensure the circuit pack was seated in the slot correctly and close the circuit pack's latches. Each circuit pack's 42 day `ticks` counter began as it was inserted. It was like a road rally race with staggered starts.

The circuit pack team fixed the problem, which took a few days to deploy. Customer support reset `ticks` manually for the circuit packs that were getting close to 42 days old so that our customers wouldn't experience anymore random reboots until the fix was deployed.

I chucked to myself, that we would have had to had to let our circuit packs soak continuously in the test lab for 42 days before we noticed it ourselves. We were lucky if the switch ran uninterrupted in the test lab for more than several hours without being rebooted.

How could we have possibly tested a circuit pack for more than 42 days?

## Become a Time Lord

<img src="https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/5160a98e-2a12-4372-b617-b393a7f960c2/d35fjuq-5118b6dc-ce1a-44d6-9040-22e4f52e83f3.png/v1/fit/w_828,h_642,q_70,strp/tardis_blueprint_file_001_by_time_lord_rassilon_d35fjuq-414w-2x.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MTI0MSIsInBhdGgiOiJcL2ZcLzUxNjBhOThlLTJhMTItNDM3Mi1iNjE3LWIzOTNhN2Y5NjBjMlwvZDM1Zmp1cS01MTE4YjZkYy1jZTFhLTQ0ZDYtOTA0MC0yMmU0ZjUyZTgzZjMucG5nIiwid2lkdGgiOiI8PTE2MDAifV1dLCJhdWQiOlsidXJuOnNlcnZpY2U6aW1hZ2Uub3BlcmF0aW9ucyJdfQ._R6wybd0hoT8-VozmX3HGZzqMvBYXW55bgFGJ-yK0dM" 
  alt="Tardis Blueprint" title="Image Source: https://www.deviantart.com/time-lord-rassilon/art/Tardis-Blueprint-File-001-190522178" width = "40%" align="right" style="padding-right: 20px;">

[_If I could turn back the hands of time._](https://springsteenlyrics.com/lyrics.php?song=turnbackthehandsoftime) — [__Bruce Springsteen__](https://en.wikipedia.org/wiki/Bruce_Springsteen)

Become a Time Lord. Take control of time in your tests. Though we may not want to turn back the hands of time as Bruce muses, we can do the following in our unit tests:
* Set a specific time, which covers cases like Y2K, leap years, etc.
* Make significant forward time jumps, which could be used to confirm the 42 day problem.
* Emulate the passage of minutes, hours or days while only needed milliseconds in the test

## The Phoenix Project Revisited
[The Phoenix Project](https://www.runn.io/blog/the-phoenix-project-summary) presents the story of technical struggles of fictional __Parts Unlimited__ company as it’s desperately trying to release its new _Phoenix Project_ application while trying to keep the rest of the company afloat.

The book has a happy ending, but their story is not over. Let’s listen in to some of my fan fiction:
>Bill Palmer, VP of IT Operations, leaned back in his chair, staring at the charts projected on the conference room screen. Sarah Madsen, Head of Analytics, tapped at her laptop. "We've confirmed it—95% of canceled orders happen within 15 minutes of placement. If we delay fulfillment by just that much, we eliminate most of the restocking costs."
>
>John Stowe, Senior Project Manager, leaned forward. "So, can we do it? Can we just hold the orders before sending them to Fulfillment?"
>
>Brent Geller, Lead Engineer, arms crossed, let out a long breath. "It's never that simple. The fulfillment system isn't designed to ‘pause’ an order once it's in the queue. We'd need a holding mechanism upstream."
>
>"Or," Patty McKee, Director of Development, interjected, "we could introduce an order confirmation buffer. Users place an order, but it sits in a pending state for 15 minutes before finalizing. That way, cancellations happen before the system commits to fulfillment."
>
>"Wouldn't that create a bad user experience?" John asked. "People expect orders to go through instantly."
>
>"Maybe not," Sarah countered. "We could frame it as a ‘grace period’ for order changes. Some customers might even appreciate the flexibility."
>
>Bill nodded. "Alright, let’s assume we build this buffer. How do we test it?"
>
>Brent rubbed his chin. "Unit testing this will be tricky. We’ll need a way to simulate time passing in our tests without actually waiting 15 minutes."
>
>Patty added, "Mocking time-dependent behavior can get messy. We’ll need robust test cases that verify orders are only processed after the soak period expires, without introducing flakiness."
>
>Bill tapped the table. "Sounds like a plan. Let's scope this out, prototype it, and validate with data. If it saves money without hurting customers, it's a win."
>
>Everyone nodded. Another problem, another solution—just another day at Parts Unlimited.

Within the `Orders` class, `Order`s are added to a `List` as they are placed. Then once a minute or so, a process thread sends each `Order` to `Fulfillment` to be fulfilled. Here’s an example of what `fulfillOrders()` looks like (__NOTE:__ The [entire code example](#complete-demo-code) is listed at the bottom of the blog):
```java
    public void fulfillOrders() {
        for (Order order : orders) {
            fulfillment.fulfill(order);
        }
        orders.clear();
    }
```

Here’s one way to implement Patty’s pending state suggestion:
```java
    public void fulfillOrders() {
        // Iterator avoids Concurrent Mutation Exceptions
        ListIterator<Order> orderIterator = orders.listIterator();
        while (orderIterator.hasNext()) {
            Order order = orderIterator.next();
            if (isMature(order)) {
                fulfillment.fulfill(order);
                orderIterator.remove();
            }
        }
    }

    private boolean isMature(Order order) {
        return order.getPlacedOrderTime().plusMinutes(15).isBefore(LocalDateTime getNow());
    }
```

This works … probably. But how can we be sure? A test for this could would take at least 15 minutes to complete. Fifteen minutes is much too long for a test, and what if we change the policy to 15 hours or 15 days? We probably wouldn't have pending orders for this long, but other applications could take this long. For example, it may take days before the notification for a delinquent payment is sent.

## Time is an External Dependency
The call to `LocalDateTime.getNow()` gives us the current time, but this is an external dependency. The `fulfillOrders()` method is tightly coupled to it as a static call.

Mockito will allow you to mock static calls, but as I mentioned in [Mocking Frameworks](https://jhumelsine.github.io/2025/03/24/legacy-code.html#mocking-frameworks), if you have to mock a static method, that’s probably an indication of a code smell that needs to be addressed.

We can also introduce a seam by extracting `LocalDateTime.getNow()` into its own method, resulting in:
```java
    private boolean isMature(Order order) {
        return order.getPlacedOrderTime().plusMinutes(15).isBefore(getNow());
    }

    LocalDateTime getNow() {
        return LocalDateTime.now();
    }
```

`isMature(…)` depends upon `getNow()`, which being a __protected-private__ method, we can override to return any value desired.  When not overridden, it will return the current time.

Then in the test, I may do something like:
```java
Orders orders = new Orders() {
    @Override
    LocalDateTime getNow() {
        return LocalDateTime.of(2025, 04, 01, 10, 30);
    }
}
```

This is quite useful when I want a specific timestamp returned for a String comparison, but in order to confirm the new 15 minute feature in `Orders` for __Parts Unlimited__ we’re going to need something a bit more sophisticated.

Since time is an external dependency, I am treating it like any other external dependency, like I would with a database or filesystem dependency. __ADD REFERNCE TO HEX ARCH BLOG__

I’ve defined `Clock` interface:
```java
interface Clock {
    LocalDateTime getNow();
}
```

`Orders` depends upon `Clock`, which will be injected into it. This simplifies `isMature(…)` to:
```java
    private boolean isMature(Order order) {
        return order.getPlacedOrderTime().plusMinutes(15).isBefore(clock.getNow());
    }
```

Here’s an example of the injected `Clock` for production, which is an [Adapter](https://jhumelsine.github.io/2023/09/29/adapter-design-pattern.html):
```java
class SystemClock implements Clock {
    @Override
    public LocalDateTime getNow() {
        return LocalDateTime.now();
    }
}
```

I created this Clock [Test Double](https://jhumelsine.github.io/2024/07/02/test-doubles.html), which allows me to advance forward any number of desired minutes:
```java
class ClockStub implements Clock {
    private LocalDateTime localDateTime;

    public ClockStub(LocalDateTime localDateTime) {
        this.localDateTime = localDateTime;
    }

    public void advanceMinutes(int minutes) {
        localDateTime = localDateTime.plusMinutes(minutes);
    }

    @Override
    public LocalDateTime getNow() {
        return localDateTime;
    }

}
```

And finally with all the parts defined, I can create unit tests that take control of time. My [demo](#complete-demo-code), found in full below, has several tests, but here is the test that illustrates a complete scenario.

It emulates the passage of 42 minutes functionally but only requires milliseconds to execute.
```java
    private static void ordersOperationalScenario() throws Exception {
        // Given
        ClockStub clockStub = new ClockStub(LocalDateTime.of(2025, 04, 01, 10, 30));
        FulfillmentSpy fulfillmentSpy  = new FulfillmentSpy();
        Orders orders = new Orders(clockStub, fulfillmentSpy);

        // When-Then: Full scenario with multiple Orders calls.

        orders.placeOrder(new Order(1, 41, 1001, 1));
        clockStub.advanceMinutes(5);
        orders.fulfillOrders();
        assertEquals("[]", fulfillmentSpy.getFulfillmentOrders().toString());

        orders.placeOrder(new Order(2, 42, 1002, 2));
        clockStub.advanceMinutes(5);
        orders.fulfillOrders();
        assertEquals("[]", fulfillmentSpy.getFulfillmentOrders().toString());

        orders.placeOrder(new Order(3, 43, 1003, 3));
        orders.cancelOrder(1);
        clockStub.advanceMinutes(16);
        orders.fulfillOrders();
        assertEquals("[Order(orderNumber=2, customerId=42, item=1002, quantity=2, placedOrderTime=2025-04-01T10:35), Order(orderNumber=3, customerId=43, item=1003, quantity=3, placedOrderTime=2025-04-01T10:40)]", fulfillmentSpy.getFulfillmentOrders().toString());

        orders.placeOrder(new Order(4, 44, 1004, 4));
        clockStub.advanceMinutes(16);
        orders.fulfillOrders();
        assertEquals("[Order(orderNumber=2, customerId=42, item=1002, quantity=2, placedOrderTime=2025-04-01T10:35), Order(orderNumber=3, customerId=43, item=1003, quantity=3, placedOrderTime=2025-04-01T10:40), Order(orderNumber=4, customerId=44, item=1004, quantity=4, placedOrderTime=2025-04-01T10:56)]", fulfillmentSpy.getFulfillmentOrders().toString());
    }
```

# Summary
__TBD__

# References
__TBD__

# Complete Demo Code
Here’s the entire implementation up to this point as one file. Copy and paste it into a Java environment and execute it. If you don’t have Java, try this [Online Java Environment](https://www.programiz.com/java-programming/online-compiler/). Add more tests. Play with the implementation. Refactor some of the code.

```java
import java.time.*;
import java.util.*;

public class TimeLord {
    public static void main(String[] args) throws Exception {
        Test.test();
    }
}

///////////// SOFTWARE UNDER TEST //////////////////

class Orders {
    private final Clock clock;
    private final Fulfillment fulfillment;
    private final List<Order> orders = new LinkedList<>();

    public Orders(Clock clock, Fulfillment fulfillment) {
        this.clock = clock;
        this.fulfillment = fulfillment;
    }

    public void placeOrder(Order order) {
        order.orderPlaced(clock.getNow());
        orders.add(order);
    }

    public void cancelOrder(int orderNumber) {
        // Iterator avoids Concurrent Mutation Exceptions
        ListIterator<Order> orderIterator = orders.listIterator();
        while (orderIterator.hasNext()) {
            Order order = orderIterator.next();
            if (order.getOrderNumber() == orderNumber) {
                orderIterator.remove();
            }
        }
    }

    public void fulfillOrders() {
        // Iterator avoids Concurrent Mutation Exceptions
        ListIterator<Order> orderIterator = orders.listIterator();
        while (orderIterator.hasNext()) {
            Order order = orderIterator.next();
            if (isMature(order)) {
                fulfillment.fulfill(order);
                orderIterator.remove();
            }
        }
    }

    private boolean isMature(Order order) {
        return order.getPlacedOrderTime().plusMinutes(15).isBefore(clock.getNow());
    }

}

class Order {
    private final int orderNumber;
    private final int customerId;
    private final int itemId;
    private final int quantity;
    private LocalDateTime placedOrderTime;

    public Order(int orderNumber, int customerId, int itemId, int quantity) {
        this.orderNumber = orderNumber;
        this.customerId = customerId;
        this.itemId = itemId;
        this.quantity = quantity;
    }

    public void orderPlaced(LocalDateTime placedOrderTime) {
        this.placedOrderTime = placedOrderTime;
    }

    public LocalDateTime getPlacedOrderTime() {
        return placedOrderTime;
    }

    public int getOrderNumber() {
        return orderNumber;
    }

    @Override 
    public String toString() {
        return String.format("Order(orderNumber=%d, customerId=%d, item=%d, quantity=%d, placedOrderTime=%s)", orderNumber, customerId, itemId, quantity, placedOrderTime.toString());
    }

}

//////////// DEPENDENCY INTERFACES AND PRODUCTION IMPLEMENTATIONS ///////////////////

interface Clock {
    LocalDateTime getNow();
}

// NOTE: This is the Adapter Design Pattern. See: https://jhumelsine.github.io/2023/09/29/adapter-design-pattern.html
class SystemClock implements Clock {
    @Override
    public LocalDateTime getNow() {
        return LocalDateTime.now();
    }
}

interface Fulfillment {
    void fulfill(Order order);
}

// We don't need ProductionFulfillment for this demo.

////////////// TEST DOUBLES /////////////////

// This Stub allows us to take control of time.
class ClockStub implements Clock {
    private LocalDateTime localDateTime;

    public ClockStub(LocalDateTime localDateTime) {
        this.localDateTime = localDateTime;
    }

    public void advanceMinutes(int minutes) {
        localDateTime = localDateTime.plusMinutes(minutes);
    }

    @Override
    public LocalDateTime getNow() {
        return localDateTime;
    }

}

// This Spy records interactions with Fulfillment
class FulfillmentSpy implements Fulfillment {
    private List<Order> fulfilledOrders = new LinkedList<>();

    @Override
    public void fulfill(Order order) {
        fulfilledOrders.add(order);
    }

    public List<Order> getFulfillmentOrders() {
        return fulfilledOrders;
    }
}

/////////////// TESTS ////////////////
class Test {
    public static void test() throws Exception {
        placedOrderNotMatureEnoughToFulfill();

        placedOrderNotQuiteMatureEnoughToFulfill();

        placedOrderMatureEnoughToFulfill();

        multipleMaturePlacedOrdersAreFulfilledButLastIsNotMature();

        canceledOrderBeforeMaturityNotFulfilled();

        ordersOperationalScenario();

        System.out.format("End Tests");
    }

    private static void placedOrderNotMatureEnoughToFulfill() throws Exception {
        // Given
        FulfillmentSpy fulfillmentSpy  = new FulfillmentSpy();
        Orders orders = new Orders(new SystemClock(), fulfillmentSpy);

        orders.placeOrder(new Order(1, 1, 1001, 1));

        // When
        orders.fulfillOrders();

        // Then
        assertEquals("[]", fulfillmentSpy.getFulfillmentOrders().toString());
    }

    private static void placedOrderNotQuiteMatureEnoughToFulfill() throws Exception {
        // Given
        ClockStub clockStub = new ClockStub(LocalDateTime.of(2025, 04, 01, 10, 30));
        FulfillmentSpy fulfillmentSpy  = new FulfillmentSpy();
        Orders orders = new Orders(clockStub, fulfillmentSpy);

        orders.placeOrder(new Order(1, 1, 1001, 1));

        clockStub.advanceMinutes(15);

        // When
        orders.fulfillOrders();

        // Then
        assertEquals("[]", fulfillmentSpy.getFulfillmentOrders().toString());
    }

    private static void placedOrderMatureEnoughToFulfill() throws Exception {
        // Given
        ClockStub clockStub = new ClockStub(LocalDateTime.of(2025, 04, 01, 10, 30));
        FulfillmentSpy fulfillmentSpy  = new FulfillmentSpy();
        Orders orders = new Orders(clockStub, fulfillmentSpy);

        orders.placeOrder(new Order(1, 1, 1001, 1));
        clockStub.advanceMinutes(16);

        // When
        orders.fulfillOrders();
        orders.fulfillOrders(); // Confirms idempotence. Fulfill should only receive the order once.

        // Then
        assertEquals("[Order(orderNumber=1, customerId=1, item=1001, quantity=1, placedOrderTime=2025-04-01T10:30)]", fulfillmentSpy.getFulfillmentOrders().toString());
    }

    private static void multipleMaturePlacedOrdersAreFulfilledButLastIsNotMature() throws Exception {
        // Given
        ClockStub clockStub = new ClockStub(LocalDateTime.of(2025, 04, 01, 10, 30));
        FulfillmentSpy fulfillmentSpy  = new FulfillmentSpy();
        Orders orders = new Orders(clockStub, fulfillmentSpy);

        orders.placeOrder(new Order(1, 41, 1001, 1));
        clockStub.advanceMinutes(5);

        orders.placeOrder(new Order(2, 42, 1002, 2));
        clockStub.advanceMinutes(5);

        orders.placeOrder(new Order(3, 43, 1003, 3));
        clockStub.advanceMinutes(15);

        // When
        orders.fulfillOrders();
        orders.fulfillOrders(); // Confirms idempotence. Fulfill should only receive an order once.

        // Then
        assertEquals("[Order(orderNumber=1, customerId=41, item=1001, quantity=1, placedOrderTime=2025-04-01T10:30), Order(orderNumber=2, customerId=42, item=1002, quantity=2, placedOrderTime=2025-04-01T10:35)]", fulfillmentSpy.getFulfillmentOrders().toString());
    }

    private static void canceledOrderBeforeMaturityNotFulfilled() throws Exception {
        // Given
        ClockStub clockStub = new ClockStub(LocalDateTime.of(2025, 04, 01, 10, 30));
        FulfillmentSpy fulfillmentSpy  = new FulfillmentSpy();
        Orders orders = new Orders(clockStub, fulfillmentSpy);

        orders.placeOrder(new Order(1, 41, 1001, 1));
        clockStub.advanceMinutes(5);

        orders.cancelOrder(1);
        clockStub.advanceMinutes(15);

        // When
        orders.fulfillOrders();

        // Then
        assertEquals("[]", fulfillmentSpy.getFulfillmentOrders().toString());
    }

    private static void ordersOperationalScenario() throws Exception {
        // Given
        ClockStub clockStub = new ClockStub(LocalDateTime.of(2025, 04, 01, 10, 30));
        FulfillmentSpy fulfillmentSpy  = new FulfillmentSpy();
        Orders orders = new Orders(clockStub, fulfillmentSpy);

        // When-Then: Full scenario with multiple Orders calls.

        orders.placeOrder(new Order(1, 41, 1001, 1));
        clockStub.advanceMinutes(5);
        orders.fulfillOrders();
        assertEquals("[]", fulfillmentSpy.getFulfillmentOrders().toString());

        orders.placeOrder(new Order(2, 42, 1002, 2));
        clockStub.advanceMinutes(5);
        orders.fulfillOrders();
        assertEquals("[]", fulfillmentSpy.getFulfillmentOrders().toString());

        orders.placeOrder(new Order(3, 43, 1003, 3));
        orders.cancelOrder(1);
        clockStub.advanceMinutes(16);
        orders.fulfillOrders();
        assertEquals("[Order(orderNumber=2, customerId=42, item=1002, quantity=2, placedOrderTime=2025-04-01T10:35), Order(orderNumber=3, customerId=43, item=1003, quantity=3, placedOrderTime=2025-04-01T10:40)]", fulfillmentSpy.getFulfillmentOrders().toString());

        orders.placeOrder(new Order(4, 44, 1004, 4));
        clockStub.advanceMinutes(16);
        orders.fulfillOrders();
        assertEquals("[Order(orderNumber=2, customerId=42, item=1002, quantity=2, placedOrderTime=2025-04-01T10:35), Order(orderNumber=3, customerId=43, item=1003, quantity=3, placedOrderTime=2025-04-01T10:40), Order(orderNumber=4, customerId=44, item=1004, quantity=4, placedOrderTime=2025-04-01T10:56)]", fulfillmentSpy.getFulfillmentOrders().toString());
    }
    
    private static void assertEquals(String expected, String actual) throws Exception {
        if (!expected.equals(actual)) {
            System.out.format("expected=%s, actual=%s\n", expected, actual);
            throw new Exception();
        }
    }

}
```
