---
title: DRAFT – Builder Design Pattern Introduction
description: TBD
unlisted: true
---

<img src="https://live.staticflickr.com/2790/4137335458_8c2de51dcb_k.jpg" alt="Bob the Builder Balloon" title="Image Source: https://www.flickr.com/photos/brianandjaclyn/4137335458" width = "70%" align="center" style="padding: 35px;">

# Introduction
TBD

# I Thought I Understood the Builder Pattern
I thought I understood the Builder Pattern, but as I continued to think about it for this blog entry and review other sources, I realized that I didn’t quite have the full picture myself. This is one of the benefits of trying to explain something to someone else. You gain a better understanding of it yourself.

Builder is the second design pattern featured by the GoF, and it comes directly after [Abstract Factory](https://jhumelsine.github.io/2025/07/30/abstract-factory.html). It has several parts, and it can be challenging to comprehend just as Abstract Factory was challenging to comprehend.  

I’ll start with a ChatGPT generated summary of the GoF’s Builder Pattern content followed by a brief summary of others before venturing into my own understanding of it.

# A ChatGPT Summary of the GoF’s Builder Pattern
The following is a summary created by ChatGPT based upon the GoF’s Builder Pattern content, which I copied from their book. The diagrams are my reproductions from their book.

---

## Builder Pattern Summary (Gang of Four)

### Intent  
Separate the **construction** of a complex object from its **representation**, so the same building process can create different representations.

---

### Why Use It?  
Imagine a document reader (like for RTF) that can output different formats—plain text, TeX, or a UI text widget. Rather than hardcoding all those output styles into the reader, Builder lets you separate the parsing logic (what the reader does) from how the output is generated (what format you want).

<img src="/assets/Builder1-1.png" alt="RTF Builder by GoF" width = "90%" align="center" style="padding-right: 35px;">

---

### Key Components

- **Builder (interface)** – Defines steps for building the product (e.g., `convertText`, `convertFont`, etc.).
- **ConcreteBuilder** – Implements the steps to build a specific representation (e.g., ASCII, TeX, UI widget).
- **Director** – Orchestrates the building process using the builder. (e.g., `RTFReader` reads and delegates token handling to the builder.)
- **Product** – The final result being built (e.g., plain text, widget object, etc.).

<img src="/assets/Builder1-2.png" alt="General Builder by GoF" width = "60%" align="center" style="padding-right: 35px;">

---

### How It Works

1. **Client** configures a **Director** with a specific **Builder**.
2. The **Director** parses input and tells the **Builder** what to build.
3. The **Builder** gradually assembles the **Product**.
4. The **Client** retrieves the finished product from the **Builder**.

<img src="/assets/Builder1-3.png" alt="Builder Sequence Diagram by GoF" width = "60%" align="center" style="padding-right: 35px;">

---

### Benefits

- ✅ **Flexible Output**: Easily swap out how the object is built without changing the parsing/creation logic.
- ✅ **Encapsulation**: Construction and representation details are hidden inside the builder.
- ✅ **Fine Control**: The object is built step-by-step, which allows for precise customization.

---

### When to Use It

- You need to build **complex objects** made of multiple parts.
- The same construction process needs to produce **different outputs**.
- You want to **hide or isolate construction logic** from the object’s representation.

---

### Real-Life Examples

- **Document Converters** – Convert formats like RTF to HTML, PDF, or plain text.
- **UI Builders** – Build forms/layouts in different platforms.
- **Game Level Builders** – Create mazes, rooms, or game worlds with different themes.
- **Compilers/Parsers** – Convert code into abstract syntax trees or bytecode.

---

### Builder vs. Abstract Factory

| Builder                          | Abstract Factory                  |
|----------------------------------|-----------------------------------|
| Builds **one complex object**    | Builds **families of objects**    |
| Constructed **step-by-step**     | Constructed **in one go**         |
| Focuses on **construction logic**| Focuses on **object families**    |

---

### In Code Terms

Think of `Director` as a loop or parser walking through input, and `Builder` as a strategy object that responds to each "event" to gradually construct a result.

```java
Director director = new RTFReader();
Builder builder = new TeXConverter();  // or ASCIIConverter, etc.
director.parse(document, builder);
Product output = builder.getResult();
```
## Summary
This pattern shines when your creation process involves multiple steps, and the output format may vary—but the steps themselves remain largely the same.

---

# The Intent Interpreted by Others
Even the ChatGPT description is a bit confusing. For example, what’s ___structure___?

Before venturing into my interpretation of Builder, let’s look at the intent provided by several other references.

## [Wikipedia Builder Pattern](https://en.wikipedia.org/wiki/Builder_pattern)
From the [Wikipedia Builder Overview](https://en.wikipedia.org/wiki/Builder_pattern#Overview)

>The builder design pattern solves problems like: 
>* How can a class (the same construction process) create different representations of a complex object?
>* How can a class that includes creating a complex object be simplified?
>
>Creating and assembling the parts of a complex object directly within a class is inflexible. It commits the class to creating a particular representation of the complex object and makes it impossible to change the representation later independently from (without having to change) the class.
>
>The builder design pattern describes how to solve such problems:
>* Encapsulate creating and assembling the parts of a complex object in a separate Builder object.
>* A class delegates object creation to a Builder object instead of creating the objects directly.
>A class (the same construction process) can delegate to different Builder objects to create different representations of a complex object.

## [Source Making Builder](https://sourcemaking.com/design_patterns/builder)
>* Separate the construction of a complex object from its representation so that the same construction process can create different representations.
>* Parse a complex representation, create one of several targets.

## [Refactoring Guru Builder](https://refactoring.guru/design-patterns/builder)
>__Builder__ is a creational design pattern that lets you construct complex objects step by step. The pattern allows you to produce different types and representations of an object using the same construction code.

## [DevIQ Builder](https://deviq.com/design-patterns/builder-pattern)]
>The Builder design pattern is a creational pattern, similar to the __Factory pattern__ (Factory Method, Abstract Factory). Unlike the Factory pattern, which typically only offers one method for creating an object, the Builder pattern offers multiple methods that can be used to gradually define the characteristics of the type to be created. This provides a more flexible interface than a single method with a large number of parameters or a complex parameter object.

# Complex Object
The word ___complex___ appears in each of the above descriptions, including the GoF’s original description.

What is a complex object? It’s an object with optional or repeating parts.

The GoF featured a `MazeBuilder` in their sample code, which allowed the client code to build a `Maze` by adding integer identified `Rooms` to the `Maze` and connecting pairs of rooms via a `Door`. Their `Maze` was a simple [undirected graph](https://en.wikipedia.org/wiki/Graph_theory#Graph).

They defined an abstract `MazeBuilder`, which returns a built `Maze`. They define two concrete `MazeBuilders`, `StandardMazeBuilder` and `CountingMazeBuilder`, where the `CountingMazeBuilder` only counts the number of `Rooms` and `Doors` added to it.

I introduced Abstract Factory in phases. I’ll do the same with Builder. As the Builder design gets more sophisticated, it will be able to handle more complex objects.

I anticipate several Builder blog entries, so I’ll stop for now and continue with more Builder examples in subsequent blog entries.

# Summary
__TBD__

# References
* [Builder Design Pattern](https://en.wikipedia.org/wiki/Builder_pattern) via Wikipedia
* [Builder Design Pattern](https://sourcemaking.com/design_patterns/builder) via Source Making
* [Builder Design Pattern](https://refactoring.guru/design-patterns/builder) via Refactoring Guru
* [Builder Design Pattern](https://deviq.com/design-patterns/builder-pattern) via DevIQ
* [Builder Design Pattern](https://www.digitalocean.com/community/tutorials/builder-design-pattern-in-java) via Digital Ocean
* [Design Patterns - Builder](https://blog.kritner.com/2020/06/06/design-patterns-builder/) Blog from Russ Hammett
* [Builder Design Pattern](https://dev.to/srishtikprasad/builder-design-pattern-3a7j) Blog from Srishti Prasad
* [Exploring Joshua Bloch’s Builder design pattern in Java](https://blogs.oracle.com/javamagazine/post/exploring-joshua-blochs-builder-design-pattern-in-java) Java Magazine Article by Frank Kiwy
* [Builder Design Pattern Explained in 10 Minutes](https://www.youtube.com/watch?v=oP76NM4qZhw) Video by Kantan Coding
* [Builder Pattern (Gang of Four Design Patterns Series)](https://www.youtube.com/watch?v=_sa2WlAFWQo) Video by Wes Doyle
* Google Search: [Builder Design Pattern](https://www.google.com/search?q=builder+design+pattern)
* Google Video Search: [Builder Design Pattern Video](https://www.google.com/search?q=builder+design+pattern+video)
