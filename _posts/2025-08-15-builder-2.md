---
title: DRAFT – Builder Design Pattern
description: From Constructor to Basic Builder
unlisted: true
---

# Introduction
TBD

# You’ve Tried the Rest, Now Try the Best
<img src="https://as1.ftcdn.net/jpg/00/27/57/96/1000_F_27579652_tM7V4fZBBw8RLmZo0Bi8WhtO2EosTRFD.jpg" alt="Pizza" title="Image Source: https://stock.adobe.com/images/supreme-pizza-lifted-slice-3/27579652
" width = "40%" align="right" style="padding: 35px;">

The bulk of this blog post will feature Java code demonstrating a complex object being declared via a traditional constructor with updates until it's declared via a Builder.

The complex object will be a `Pizza` class for which instances declare the pizza size with optional toppings. I'm only concerned with declaring a `Pizza` instance in this blog. There won't be any behavior related methods except for a `toString()` method, which formats and returns a String descripiton of the `Pizza` instance.

## Constructor Implementation
My initial design declares `Pizza` with a constructor that declares the size and several toppings as constructor arguments:
```java
import java.util.*;

public class PizzaBuilder1 {
    public static void main(String[] args) {
        Pizza pizza1 = new Pizza(Pizza.Size.LARGE, true, false, true, false);

        System.out.println(pizza1);

        Pizza pizza2 = new Pizza(Pizza.Size.MEDIUM, true, true, true, true);

        System.out.println(pizza2);

        Pizza pizza3 = new Pizza(Pizza.Size.SMALL, false, false, false, false);

        System.out.println(pizza3);
    }

}

public class Pizza {

    public enum Size {
        SMALL, MEDIUM, LARGE
    }

    private final Size size;
    private final boolean pepperoni;
    private final boolean peppers;
    private final boolean onions;
    private final boolean blackOlives;

    public Pizza(Size size, boolean pepperoni, boolean peppers, boolean onions, boolean blackOlives) {
        this.size = size;
        this.pepperoni = pepperoni;
        this.peppers = peppers;
        this.onions = onions;
        this.blackOlives = blackOlives;
    }

    @Override
    public String toString() {
        StringBuilder description = new StringBuilder();
        description.append("Pizza Size: ").append(size);

        description.append(" with toppings:");
        boolean hasToppings = false;

        if (pepperoni) {
            description.append(" Pepperoni");
            hasToppings = true;
        }
        if (peppers) {
            if (hasToppings) description.append(",");
            description.append(" Peppers");
            hasToppings = true;
        }
        if (onions) {
            if (hasToppings) description.append(",");
            description.append(" Onions");
            hasToppings = true;
        }
        if (blackOlives) {
            if (hasToppings) description.append(",");
            description.append(" Black Olives");
            hasToppings = true;
        }

        if (!hasToppings) {
            description.append(" None");
        }

        return description.toString();
    }
}

```

`Pizza` is a Value Object, which I’ll blog about in the future (TBD). Its attributes are `final`, meaning that any `Pizza` object is immutable, which is a desirable, but there are few parts of this basic design that I don’t like:
* The constructor with defines the `Size` parameter along with four boolean parameters/arguments A large number of arguments, especially when booleans, can be confusing. It’s not obvious which boolean argument value aligns with which parameter. Most IDEs will add the field name, which provides some context, but that also violates encapsulation to some degree.
* These are not the only boolean topping options. I limited it to four just so it would be manageable, but I easily envision a dozen or more topping options, which would make the constructor parameter list even more confusing. And if we added another topping, it could force modifications in every Pizza constructor reference.

__NOTE:__ The only issue I have with this `Pizza` implementation is the number of parameters defined in the constructor, especially since they could continue to accumulate. If `Pizza` had a smaller constructor parameter list with more context and stable, then I would have no issues with this implementation. Most classes tend to have stable context oriented constructor parameter lists.

## Constructor to Set Accessors
There’s more than one way to inject field attribute values into an object. The constructor is one option, but set accessors are another.

Here’s an implementation that reduces the constructor to one argument and allows the client code to add toppings as needed:
```java
import java.util.*;

public class PizzaBuilder2 {
    public static void main(String[] args) {
        Pizza pizza1 = new Pizza(Pizza.Size.LARGE);
        pizza1.addPepperoni();
        pizza1.addOnions();

        System.out.println(pizza1);

        Pizza pizza2 = new Pizza(Pizza.Size.MEDIUM);
        pizza2.addPepperoni();
        pizza2.addPepperoni();
        pizza2.addOnions();
        pizza2.addBlackOlives();

        System.out.println(pizza2);

        Pizza pizza3 = new Pizza(Pizza.Size.SMALL);

        System.out.println(pizza3);
    }

}

public class Pizza {

    public enum Size {
        SMALL, MEDIUM, LARGE
    }

    private final Size size;
    private boolean pepperoni = false;
    private boolean peppers = false;
    private boolean onions = false;
    private boolean blackOlives = false;

    public Pizza(Size size) {
        this.size = size;
    }

    public void addPepperoni() {
        pepperoni = true;
    }

    public void addPeppers() {
        peppers = true;
    }

    public void addOnions() {
        onions = true;
    }

    public void addBlackOlives() {
        blackOlives = true;
    }

    @Override
    public String toString() {
        // Same toString() implementation as above. It will not change as the design progresses.
    }
}
```

This solves the long constructor argument problem and it provides more context, since the accessors have meaningful names. But it’s broken the class initialization into different statements, and we’ve lost the immutable nature of the previous implementation. A new topping can be added at any time, which probably isn’t desirable.

## Chaining Accessors
This update modifies the accessors slightly so that they return `this` rather than `void`. This allows us to chain the `Pizza` construction making it feel more like a unit:
```java
import java.util.*;

public class PizzaBuilder2 {
    public static void main(String[] args) {
        Pizza pizza1 = new Pizza(Pizza.Size.LARGE)
            .addPepperoni()
            .addOnions();

        System.out.println(pizza1);

        Pizza pizza2 = new Pizza(Pizza.Size.MEDIUM)
            .addPepperoni()
            .addPepperoni()
            .addOnions()
            .addBlackOlives();

        System.out.println(pizza2);

        Pizza pizza3 = new Pizza(Pizza.Size.SMALL);

        System.out.println(pizza3);
    }

}

public class Pizza {

    public enum Size {
        SMALL, MEDIUM, LARGE
    }

    private final Size size;
    private boolean pepperoni = false;
    private boolean peppers = false;
    private boolean onions = false;
    private boolean blackOlives = false;

    public Pizza(Size size) {
        this.size = size;
    }

    public Pizza addPepperoni() {
        pepperoni = true;
        return this;
    }

    public Pizza addPeppers() {
        peppers = true;
        return this;
    }

    public Pizza addOnions() {
        onions = true;
        return this;
    }

    public Pizza addBlackOlives() {
        blackOlives = true;
        return this;
    }

    @Override
    public String toString() {
        // Same toString() implementation original.
    }

}
```

This is a bit better, but it’s just syntactic sugar. The `Pizza` object is still mutable and a new topping can be added at any time.

## The Pizza.Builder
This implementation is the union of the first and third implementations, where `Pizza` is immutable and `Pizza.Builder` allows chaining. For a more detailed description see [Exploring Joshua Bloch’s Builder design pattern in Java](https://blogs.oracle.com/javamagazine/post/exploring-joshua-blochs-builder-design-pattern-in-java).
```java
import java.util.*;

public class PizzaBuilder2 {
    public static void main(String[] args) {
        Pizza pizza1 = new Pizza.Builder(Pizza.Size.LARGE)
            .addPepperoni()
            .addOnions()
            .build();

        System.out.println(pizza1);

        Pizza pizza2 = new Pizza.Builder(Pizza.Size.MEDIUM)
            .addPepperoni()
            .addPepperoni()
            .addOnions()
            .addBlackOlives()
            .build();

        System.out.println(pizza2);

        Pizza pizza3 = new Pizza.Builder(Pizza.Size.SMALL)
            .build();

        System.out.println(pizza3);
    }

}

public class Pizza {

    public enum Size {
        SMALL, MEDIUM, LARGE
    }

    private final Size size;
    private final boolean pepperoni;
    private final boolean peppers;
    private final boolean onions;
    private final boolean blackOlives;

    private Pizza(Builder builder) {
        this.size = builder.size;
        this.pepperoni = builder.pepperoni;
        this.peppers = builder.peppers;
        this.onions = builder.onions;
        this.blackOlives = builder.blackOlives;
    }

    public static class Builder {
        private Size size;
        private boolean pepperoni = false;
        private boolean peppers = false;
        private boolean onions = false;
        private boolean blackOlives = false;

        public Builder(Size size) {
            this.size = size;
        }

        public Builder addPepperoni() {
            pepperoni = true;
            return this;
        }

        public Builder addPeppers() {
            peppers = true;
            return this;
        }

        public Builder addOnions() {
            onions = true;
            return this;
        }

        public Builder addBlackOlives() {
            blackOlives = true;
            return this;
        }

        public Pizza build() {
            return new Pizza(this);
        }
    }
    @Override
    public String toString() {
        // Same toString() implementation original.
    }


}
```

There’s a bit more to this implementation, but it ensures that `Pizza` can only be constructed via the `Pizza.Builder` and once built, it’s immutable.

# Summary
This blog entry has shown the progression of a complex object from a long constructor parameter list to one that allows the object to be constructed step-by-step with a Builder.

However, it hasn’t demonstrated several features usually associated with Builder, such as building the complex object from a specification script and being able to build different types of products from a specification.

I’ll continue with a specification script in the next blog entry.

# References
__TBD__ Link to previous blog’s references.

# Complete Demo Code
Here’s the entire implementation up to this point as one file. Copy and paste it into a Java environment and execute it. If you don’t have Java, try this [Online Java Environment](https://www.programiz.com/java-programming/online-compiler/). Add more tests. Play with the implementation. Refactor some of the code.

## Constructor
```java
import java.util.*;

public class PizzaBuilder1 {
    public static void main(String[] args) {
        Pizza pizza1 = new Pizza(Pizza.Size.LARGE, true, false, true, false);

        System.out.println(pizza1);

        Pizza pizza2 = new Pizza(Pizza.Size.MEDIUM, true, true, true, true);

        System.out.println(pizza2);

        Pizza pizza3 = new Pizza(Pizza.Size.SMALL, false, false, false, false);

        System.out.println(pizza3);
    }

}

public class Pizza {

    public enum Size {
        SMALL, MEDIUM, LARGE
    }

    private final Size size;
    private final boolean pepperoni;
    private final boolean peppers;
    private final boolean onions;
    private final boolean blackOlives;

    public Pizza(Size size, boolean pepperoni, boolean peppers, boolean onions, boolean blackOlives) {
        this.size = size;
        this.pepperoni = pepperoni;
        this.peppers = peppers;
        this.onions = onions;
        this.blackOlives = blackOlives;
    }

    @Override
    public String toString() {
        StringBuilder description = new StringBuilder();
        description.append("Pizza Size: ").append(size);

        description.append(" with toppings:");
        boolean hasToppings = false;

        if (pepperoni) {
            description.append(" Pepperoni");
            hasToppings = true;
        }
        if (peppers) {
            if (hasToppings) description.append(",");
            description.append(" Peppers");
            hasToppings = true;
        }
        if (onions) {
            if (hasToppings) description.append(",");
            description.append(" Onions");
            hasToppings = true;
        }
        if (blackOlives) {
            if (hasToppings) description.append(",");
            description.append(" Black Olives");
            hasToppings = true;
        }

        if (!hasToppings) {
            description.append(" None");
        }

        return description.toString();
    }
}
```

## Set Accessors
```java
import java.util.*;

public class PizzaBuilder2 {
    public static void main(String[] args) {
        Pizza pizza1 = new Pizza(Pizza.Size.LARGE);
        pizza1.addPepperoni();
        pizza1.addOnions();

        System.out.println(pizza1);

        Pizza pizza2 = new Pizza(Pizza.Size.MEDIUM);
        pizza2.addPepperoni();
        pizza2.addPepperoni();
        pizza2.addOnions();
        pizza2.addBlackOlives();

        System.out.println(pizza2);

        Pizza pizza3 = new Pizza(Pizza.Size.SMALL);

        System.out.println(pizza3);
    }

}

public class Pizza {

    public enum Size {
        SMALL, MEDIUM, LARGE
    }

    private final Size size;
    private boolean pepperoni = false;
    private boolean peppers = false;
    private boolean onions = false;
    private boolean blackOlives = false;

    public Pizza(Size size) {
        this.size = size;
    }

    public void addPepperoni() {
        pepperoni = true;
    }

    public void addPeppers() {
        peppers = true;
    }

    public void addOnions() {
        onions = true;
    }

    public void addBlackOlives() {
        blackOlives = true;
    }

    @Override
    public String toString() {
        StringBuilder description = new StringBuilder();
        description.append("Pizza Size: ").append(size);

        description.append(" with toppings:");
        boolean hasToppings = false;

        if (pepperoni) {
            description.append(" Pepperoni");
            hasToppings = true;
        }
        if (peppers) {
            if (hasToppings) description.append(",");
            description.append(" Peppers");
            hasToppings = true;
        }
        if (onions) {
            if (hasToppings) description.append(",");
            description.append(" Onions");
            hasToppings = true;
        }
        if (blackOlives) {
            if (hasToppings) description.append(",");
            description.append(" Black Olives");
            hasToppings = true;
        }

        if (!hasToppings) {
            description.append(" None");
        }

        return description.toString();
    }
}
```

## Chaining
```java
import java.util.*;

public class PizzaBuilder2 {
    public static void main(String[] args) {
        Pizza pizza1 = new Pizza(Pizza.Size.LARGE)
            .addPepperoni()
            .addOnions();

        System.out.println(pizza1);

        Pizza pizza2 = new Pizza(Pizza.Size.MEDIUM)
            .addPepperoni()
            .addPepperoni()
            .addOnions()
            .addBlackOlives();

        System.out.println(pizza2);

        Pizza pizza3 = new Pizza(Pizza.Size.SMALL);

        System.out.println(pizza3);
    }

}

public class Pizza {

    public enum Size {
        SMALL, MEDIUM, LARGE
    }

    private final Size size;
    private boolean pepperoni = false;
    private boolean peppers = false;
    private boolean onions = false;
    private boolean blackOlives = false;

    public Pizza(Size size) {
        this.size = size;
    }

    public Pizza addPepperoni() {
        pepperoni = true;
        return this;
    }

    public Pizza addPeppers() {
        peppers = true;
        return this;
    }

    public Pizza addOnions() {
        onions = true;
        return this;
    }

    public Pizza addBlackOlives() {
        blackOlives = true;
        return this;
    }

    @Override
    public String toString() {
        StringBuilder description = new StringBuilder();
        description.append("Pizza Size: ").append(size);

        description.append(" with toppings:");
        boolean hasToppings = false;

        if (pepperoni) {
            description.append(" Pepperoni");
            hasToppings = true;
        }
        if (peppers) {
            if (hasToppings) description.append(",");
            description.append(" Peppers");
            hasToppings = true;
        }
        if (onions) {
            if (hasToppings) description.append(",");
            description.append(" Onions");
            hasToppings = true;
        }
        if (blackOlives) {
            if (hasToppings) description.append(",");
            description.append(" Black Olives");
            hasToppings = true;
        }

        if (!hasToppings) {
            description.append(" None");
        }

        return description.toString();
    }
}

```

## Builder
```java
import java.util.*;

public class PizzaBuilder2 {
    public static void main(String[] args) {
        Pizza pizza1 = new Pizza.Builder(Pizza.Size.LARGE)
            .addPepperoni()
            .addOnions()
            .build();

        System.out.println(pizza1);

        Pizza pizza2 = new Pizza.Builder(Pizza.Size.MEDIUM)
            .addPepperoni()
            .addPepperoni()
            .addOnions()
            .addBlackOlives()
            .build();

        System.out.println(pizza2);

        Pizza pizza3 = new Pizza.Builder(Pizza.Size.SMALL)
            .build();

        System.out.println(pizza3);
    }

}

public class Pizza {

    public enum Size {
        SMALL, MEDIUM, LARGE
    }

    private final Size size;
    private final boolean pepperoni;
    private final boolean peppers;
    private final boolean onions;
    private final boolean blackOlives;

    private Pizza(Builder builder) {
        this.size = builder.size;
        this.pepperoni = builder.pepperoni;
        this.peppers = builder.peppers;
        this.onions = builder.onions;
        this.blackOlives = builder.blackOlives;
    }

    public static class Builder {
        private Size size;
        private boolean pepperoni = false;
        private boolean peppers = false;
        private boolean onions = false;
        private boolean blackOlives = false;

        public Builder(Size size) {
            this.size = size;
        }

        public Builder addPepperoni() {
            pepperoni = true;
            return this;
        }

        public Builder addPeppers() {
            peppers = true;
            return this;
        }

        public Builder addOnions() {
            onions = true;
            return this;
        }

        public Builder addBlackOlives() {
            blackOlives = true;
            return this;
        }

        public Pizza build() {
            return new Pizza(this);
        }
    }

    @Override
    public String toString() {
        StringBuilder description = new StringBuilder();
        description.append("Pizza Size: ").append(size);

        description.append(" with toppings:");
        boolean hasToppings = false;

        if (pepperoni) {
            description.append(" Pepperoni");
            hasToppings = true;
        }
        if (peppers) {
            if (hasToppings) description.append(",");
            description.append(" Peppers");
            hasToppings = true;
        }
        if (onions) {
            if (hasToppings) description.append(",");
            description.append(" Onions");
            hasToppings = true;
        }
        if (blackOlives) {
            if (hasToppings) description.append(",");
            description.append(" Black Olives");
            hasToppings = true;
        }

        if (!hasToppings) {
            description.append(" None");
        }

        return description.toString();
    }
}

```
