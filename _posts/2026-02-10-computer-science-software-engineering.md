---
title: WORK IN PROGRESS – Career Path Introduction
description: Computer Science and Software Engineering
unlisted: true
---

# Introduction
I mentor several Computer Science undergraduates attending the university where I received my Bachelors in Computer Science almost 45 years ago.

Many of them ask me the same career path questions about internships, getting their first job and onboarding.
Addressing these career path questions will be my next series.
One of the entries already exists, which I wrote about a year and a half ago with [Losing Your Job Stinks](https://jhumelsine.github.io/2024/08/11/jobsearch.html).

This series won't be as technical as other blog entries.
It will represent my own opinions career development and I know that many others may will have their own opinions as well.
My opinions may be out of date, since [Generative AI](https://jhumelsine.github.io/2024/09/18/llm-genai.html) was just coming onto the scene when I retired in 2023.

# Computer Science is not Software Engineering
_In science if you know what you are doing you should not be doing it. In engineering if you do not know what you are doing you should not be doing it._ — Richard Hamming

My degrees are in [**Computer Science**](https://en.wikipedia.org/wiki/Computer_science).
My mentees' degrees will be in **Computer Science**. But what we practice in industry is [**Software Engineering**](https://en.wikipedia.org/wiki/Software_engineering).

Computer Science and Software Engineering are related yet different.
***Computer Science is to Software Engineering and Chemistry is to Chemical Engineering***.
They have a lot in common, but the former of each pair is about the science and the latter is about the application.

**Computer Science** is how to get the computer to do what you want it to do.
**Software Engineering** is how a group of people get the computer to do what they think the customer wants the computer to do in such a way that they can easily change it when the customer tells them that what it does isn't what they wanted.

In a **Computer Science** degree, you're usually expected and often required to do your own work alone.
In a **Software Engineering** career, you're usually expected to work with a team.

**Computer Science** programs tend to have a lifespan of one to two weeks.
They tend to be relatively small, written completely by the student and once handed in, never revisted.
**Software Engineering** programs tend to have a lifespan of months to years to decades.
They tend to be large, written by teams and require constant maintenance.

**Computer Science** is about technology and mathematical rigor.
**Software Engineering** is about communication with others. It's a social science.

One needs some degree of **Computer Science** to practice **Software Engineering**.
They are related yet different disciplines.
I don't know that academia necessarily conveys that distinction well at universities these days.
I think it's getting better with **Software Engineering** courses, but I don't think academia has a full grasp on on the distinction between **Computer Science** and **Software Engineering** quite yet.
Maybe I'm wrong.
I hope so.

## Computer Science Problems
Computer Science addresses well defined problems of bounded scope/domain that don't tend to change over time.
These problems tend to have provable solutions.

Typical problems and topics data structures, algorithms, discrete mathematics, programming language design, etc.
Computer Science curriculums introduce students to the entire computer tech stack from logic gates at the bottom up to applications at the top.
I used to chuckle to myself that the title of every college Computer Science text book I had through my undergraduate degree and some of my graduate degree often began with _An Introduction to ..._
When were we going to get past the introduction?

These are foundational concepts.
They lift the veil of mystery.
A computer isn't a magical blackbox.
We obtain some degree of understand as to what's going on under the hood.

Your career tends to narrow and focus upon a specific section of the tech stack.
For most of us, I suspect it tends to be at the application layer.
For others, it's lower in the stack.

Knowledge of the operationg system is useful as an application developer, but it's usually not necessary.
Additional layers of abstraction, such as [Virtual Machines](https://en.wikipedia.org/wiki/Virtual_machine) and [Containers](https://en.wikipedia.org/wiki/Containerization_(computing)) make lower level details even less relevant.

This doesn't lack of Computer Science relevance doesn't restrict itself to tech stack layers.
Data Structures was a major prerequesite course in the early 1980s.
If you needed a data structure, you had to build it yourself.
Now almost every major data structure is either built into the language or available via a utility library.
If not, then there's probably an open source library that provides it.
However, the knowledge I learned in being able to build my own data structures has greatly aided me in understanding the behaviors and complexity performance of provided data structures.

Sorting is a major topic of study.
I **never** had to implement `sort()` in my 38 year career.
The only time I have ever been required to implement [Quick Sort](https://en.wikipedia.org/wiki/Quicksort) has been part of a programming assignment for a Computer Science course.

I suspect that sorting is still a major topic in Computer Science because:
* It was a major problem to solve in its day
* It's tradition/inertia
* It's a well defined problem that students can understand
* It's a good teaching tool, since there are many approaches that solve sorting with different space and time efficiences. It's a good model to teach algorithms, complexity analysis, etc.

Just as I have never been required to write a `sort()` program, design a data structure or provide [Big-O](https://en.wikipedia.org/wiki/Big_O_notation) analysis, the knowledge of how to do these served me well throughout my career.

Computer Science is a hard science. Its hard science cousin would be mathematics.

**Sadly, the types of problems you learn to solve in academia are rarely the types of problems you'll encounter in your career.**

## Software Engineering Problems
Software Engineering addresses vaguely defined problems of fuzzier scope/domain that do tend to change over time.
These problems tend to have testable solutions.
I'm specifically thinking of applications that paying customers request.

A Computer Science degree creates a good foundation, but a degree alone is not sufficient for Software Engineering.
A degree is not the end of your education, it's the beginning.

The half-life for technology in the Computer Science field is about three to five years and possibly even tighter with the advent of [Generative AI](https://jhumelsine.github.io/2024/09/18/llm-genai.html).
All technology I learned in college was mostly obsolete a decade or so into my career.
The primary programming language at my university was [PL/C](https://en.wikipedia.org/wiki/PL/C), which was a Cornell derived subset of [PL/I](https://en.wikipedia.org/wiki/PL/I), which stood for _Programming Language One_.
We also had a brief foray into [Fortran](https://en.wikipedia.org/wiki/Fortran) 77.
My Programming Languages course introduced us to [List](https://en.wikipedia.org/wiki/Lisp_(programming_language)), [SNOBOL](https://en.wikipedia.org/wiki/SNOBOL) and [APL](https://en.wikipedia.org/wiki/APL_(programming_language)), which always felt like reading Greek from right to left.
The source language for my Compiler class was [Pascal](https://en.wikipedia.org/wiki/Pascal_(programming_language)), the new and upcoming programming language.

The only courses that retained their relevance through my career were not technology intensive. These were the theory and general principle courses, such as [Graph Theory](https://en.wikipedia.org/wiki/Graph_theory), [Automata Theory](https://en.wikipedia.org/wiki/Automata_theory) and [Data Structures](https://en.wikipedia.org/wiki/Data_structure) and [Algorithms](https://en.wikipedia.org/wiki/Algorithm).
Since they're based upon mathematical rigor, they tend to be evergreen.
While I didn't use content from these courses directly, they provided a solid foundation upon which I could continue to learn as the field advanced.

Throughout my career I had to pick up new technology, such as:
* [Object-Oriented Programming](https://en.wikipedia.org/wiki/Object-oriented_programming)
* [The Internet](https://en.wikipedia.org/wiki/Internet)
* [Cloud Computing](https://en.wikipedia.org/wiki/Cloud_computing)
* [Mobile Apps](https://en.wikipedia.org/wiki/Mobile_app)
* [Containers](https://en.wikipedia.org/wiki/Containerization_(computing))
* [NoSQLs](https://en.wikipedia.org/wiki/NoSQL)

But there's more than changes to technology too. 

Software Engineering is a soft science. It's about working with other people to solve problems often with computers. Its soft science cousin would be sociology, with maybe a bit of economics mixed in.

# Career Path Series
I plan to include the following in this series. This is just a working list. None of these are set in stone yet:
* Getting an Internship (TBD)
* Getting Your First Job (TBD)
* Onboarding (TBD)
* Your Career Journey (TBD)
* [Losing Your Job Stinks](TBD)
* Retiring (TBD)

# Summary
TBD

# References
TBD
