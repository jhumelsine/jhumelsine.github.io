---
title: DRAFT – Creational Design Patterns
description: Various mechanisms to create objects without calling new directly
unlisted: true
---

<img src="https://cdn2.picryl.com/photo/2016/12/31/god-creating-heaven-and-earth-lacma-653754-1bdc56-1024.jpg" alt="God creating heaven and earth" title="Image Source: https://itoldya420.getarchive.net/amp/media/god-creating-heaven-and-earth-lacma-653754-1bdc56" width = "50%" align="center" style="padding: 35px;">
 
# Introduction
After a year-long diversion into [Automated Testing](https://jhumelsine.github.io/3000/01/01/preface.html#automated-testing), I’ve completed the series, and I’m moving back to Design Patterns with a series on Creational Design Patterns.

I had a few ideas in my head about what I’d like to write to set the stage on this landing page. I checked my previous blog entries to find that I’ve covered most of them previously. So, I’m going to regroup, summarize those ideas here, provide reference links to previous blogs, and set the stage to move ahead with the series.

# The Gang of Four’s Creational Design Patterns
The Gang of Four (GoF) organized their catalog of Design Patterns into three major groups, with the first group being the __Creational Design Patterns__. The other two are [Structural Design Patterns](https://refactoring.guru/design-patterns/structural-patterns) and [Behavioral Design Patterns](https://refactoring.guru/design-patterns/behavioral-patterns). Structural focuses upon the organization of objects and behavioral focuses upon their behaviors. Quite frankly, I’ve often felt like the GoF’s organization between these two categories is somewhat arbitrary, which is why I probably won't blog about these two groups.

I introduced the [Gang Of Four Creational Design Pattern Inventory](https://jhumelsine.github.io/2023/10/07/factory-design-patterns.html#gang-of-four-creational-design-pattern-inventory) as a section within the [Factory Design Pattern](https://jhumelsine.github.io/2023/10/07/factory-design-patterns.html), but I didn't go into too much detail. I'll provide more detail in this series.

These are patterns that allow the caller to acquire an object without being coupled to the class type for the object returned. The caller will reference the objects as an abstraction, such as an interface, which aligns with the GOF’s first design principle: [___Program to an interface, not an implementation___](https://jhumelsine.github.io/2023/09/06/design-pattern-principles.html#program-to-an-interface-not-an-implementation).

Programming to an interface decouples software components and encourages a more modular design. It allows different class types to satisfy the caller’s reference including [Test Doubles](https://jhumelsine.github.io/2024/07/02/test-doubles.html) which makes testing easier.

# The Creational Design Patterns
The GoF declared five Creational Design Patterns. I include a few more. Here is my set, each of which will link to a blog dedicated to that pattern when written:
* [__Factory__](https://jhumelsine.github.io/2023/10/07/factory-design-patterns.html) – Factory creates and returns an object without the caller having to know the object’s class type. I consider it one of the [Essential Design Patterns](https://jhumelsine.github.io/2023/09/07/essential-design-patterns.html), which is why I featured it almost two years ago.
* __Abstract Factory__ – Most Creational Design Patterns feature static methods defined in concrete classes known to the caller, even if the caller is an external [Configurer](https://jhumelsine.github.io/2023/10/09/dependency-injection-design-pattern.html#configurer) to the primary business logic. With Abstract Factory the caller doesn’t know the Factory’s class type. The caller accesses the Factory as an interface. This allows a design to inject any Factory into the business logic. Abstract Factories have at least two primary features:
    * An Abstract Factory is often a Factory of Factories. This ensures that cohesive objects of different types are created are consistent. For example, if the caller requires several objects, Abstract Factory helps ensure that those objects will all be for production, testing or any other environment or scenario.
    * When the business logic requires multiple objects to be created, Abstract Factory ensures that those objects can be created without coupling the business logic to a specific Factory.
* __Builder__ – Most Creational Design Patterns create and return one instance of a class. Builder creates, assembles and returns a set of cohesive objects. It’s often used with [Composable Design Patterns](https://jhumelsine.github.io/2024/01/03/composable-design-patterns-basic-concepts.html). The Builder may also be the [Configurer](https://jhumelsine.github.io/2023/10/09/dependency-injection-design-pattern.html#configurer) for a Composable Design Pattern. Builder has two primary features:
   * The creation and assembly of cohesive objects based upon a specification much like a blueprint. This _specification_ is not the same as the [Specification Design Pattern](https://jhumelsine.github.io/2024/03/06/specification-design-pattern.html); although, the Specification Design Pattern could be configured using Builder. The common name is unfortunate.
    * The Builder pattern supports abstraction. Different concrete Builders can resolve the abstraction within the same design allowing them create and assemble different concrete instances of the same structure using the [Strategy Design Pattern](https://jhumelsine.github.io/2023/09/21/strategy-design-pattern.html).
* __Singleton__ – Some objects should have exactly one instance, such as: [Spoolers]( https://en.wikipedia.org/wiki/Spooling), [File Systems](https://en.wikipedia.org/wiki/File_system), [System Clock](https://en.wikipedia.org/wiki/System_time), [Repositories](https://en.wikipedia.org/wiki/Repository), etc. Singleton ensures that one only object is created for a class type. Unfortunately, Singleton tends to be overused and have a lot of baggage associated with it. Even the GoF made a few mistakes in the Singleton portion of their book.
* __Flyweight__ (Also Known As Multiton) – The GoF cataloged Flyweight as a [Structural Design Pattern](https://refactoring.guru/design-patterns/structural-patterns), but I feel it’s really a Creational Design Pattern. It’s a multiple instance version of Singleton, which sounds like a contradiction, but it’s not. Flyweight ensures that only one instance of an object will be created for a given set of attributes. If an object is requested with an attribute profile that matches a previously created object, then the previously created object will be returned. If the object has a new attribute profile, then a new object will be created and returned. ___Multion___ is a play on words, as in _Multiple Singleton_.
* __Prototype__ – All other Creational Design Patterns know the set of concrete class types they create, even if they encapsulate this information from the caller. Prototype is unique in that this pattern doesn’t know the concrete classes it creates. Prototype creates new objects by instructing another object to create a copy of itself. Prototype is useful when we don’t want to update a Factory every time a new class type is added to the design. The name is unfortunate. _Prototype_ is not the same concept as prototyping code for a proof-of-concept exercise. I feel that __Breeder__ or __Cloner__ may have been a better name for the pattern, but no one asked me.
* __Object Pool__ – This pattern is not in the GoF Design Pattern catalog. It’s similar to __Flyweight__ but still different. With Flyweight, objects are created as needed and shared subsequently. With Object Pool, objects are created at start up and lent to the caller when requested. They are not shared with others. They must be returned by the caller. Rental cars, library books and bowling alley shoes are real world examples of Object Pools.
* [__Dependency Injection__](https://jhumelsine.github.io/2023/10/09/dependency-injection-design-pattern.html) – Dependency Injection is not in the GoF’s catalog, but it should have been. Technically, it’s not actually creating objects, but it’s such an integral concept with object creation, that I feel it should have honorary creational status. Dependency Injection removes object creation from the application altogether by creating the object externally in a [Configurer](https://jhumelsine.github.io/2023/10/09/dependency-injection-design-pattern.html#configurer) and injecting it as a dependency into the application. I consider it one of the [Essential Design Patterns](https://jhumelsine.github.io/2023/09/07/essential-design-patterns.html), which is why I featured it almost two years ago.

# What the GoF Missed
The GoF [missed a few things]( https://jhumelsine.github.io/2023/10/07/factory-design-patterns.html#creational-design-pattern--goofs), which I’ve addressed previously:
* They were concerned with encapsulation, but they didn’t observe it in their Creational Design Pattern nomenclature. Most Creational Design Patterns have different method names, such as `create()`, `make()`, `getInstance()`, `construct()`, and `clone()`. They convey the creation mechanism, which makes them less flexible. I prefer a method name that conveys the client’s desires more than the creational mechanism, `acquire()`, which I’ll use in my subsequent design pattern examples.
* They were a little sloppy with memory management. They don’t address it, and some of their pattern examples, especially in C++, leak memory. Garbage collection languages, such as Java, don’t require as much memory management as C++, but there are some considerations, which I’ll present with specific patterns. I had already presented this in [The Omission of Sin](https://jhumelsine.github.io/2024/02/01/proxy-design-pattern.html#the-sin-of-omission) within the [Proxy Design Pattern](https://jhumelsine.github.io/2024/02/01/proxy-design-pattern.html). This will not be the only time I use the Proxy Design Pattern with a Creational Design Pattern.

# Creational Design Patterns Are Not Mutually Exclusive
Creational Design Patterns are not mutually exclusive. They can work together. For example, Builder could be used to create and assemble a [Composite Tree](https://jhumelsine.github.io/2024/02/27/composite-design-pattern.html#design-structure). The Leaf nodes in this tree could be Singletons or Flyweights.

# Summary
__TBD__

# References
* [Creational Design Patterns](https://en.wikipedia.org/wiki/Creational_pattern) via Wikipedia
* [Creational Design Patterns](https://sourcemaking.com/design_patterns/creational_patterns) via SourceMaking
* [Creational Design Patterns](https://refactoring.guru/design-patterns/creational-patterns) via RefactoringGuru
* [Introduction to Creational Design Patterns](https://www.baeldung.com/creational-design-patterns) via Baeldung
* [Understanding Creational Design Patterns: Building Blocks of Object Creation](https://dev.to/srishtikprasad/understanding-creational-design-patterns-building-blocks-of-object-creation-n44) blog by Srishti Prasad
* Google Search: [creational design patterns](https://www.google.com/search?q=creational+design+patterns)
